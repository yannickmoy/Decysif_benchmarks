;; produced by cvc5.drv ;;
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort us_private 0)

(declare-const us_null_ext__ us_private)

(declare-sort status 0)

;; "in_range"
(define-fun in_range ((x Int)) Bool
  (and (<= 0 x) (<= x 1)))

;; "to_rep"
(declare-fun to_rep (status) Int)

;; "of_rep"
(declare-fun of_rep (Int) status)

;; "inversion_axiom"
(assert
  (forall ((x status)) (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; "range_axiom"
(assert
  (forall ((x status)) (! (in_range (to_rep x)) :pattern ((to_rep x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                               (of_rep x))) )))

;; "bool_eq"
(define-fun bool_eq ((a (Array Int status)) (a__first Int) (a__last Int) (b (Array Int status)) (b__first Int) (b__last Int)) Bool
  (ite (and
         (ite (<= a__first a__last)
           (and
             (<= b__first b__last)
             (= (- a__last a__first) (- b__last b__first)))
           (< b__last b__first))
         (forall ((temp___idx_168 Int))
           (=>
             (and (<= a__first temp___idx_168) (<= temp___idx_168 a__last))
             (= (to_rep (select a temp___idx_168)) (to_rep
                                                     (select b (+ (- b__first a__first) temp___idx_168)))))))
    true
    false))

;; "bool_eq_rev"
(assert
  (forall ((a (Array Int status)) (b (Array Int status)))
    (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
      (=>
        (= (bool_eq b b__first b__last a a__first a__last) true)
        (and
          (ite (<= a__first a__last)
            (and
              (<= b__first b__last)
              (= (- a__last a__first) (- b__last b__first)))
            (< b__last b__first))
          (forall ((temp___idx_168 Int))
            (=>
              (and (<= a__first temp___idx_168) (<= temp___idx_168 a__last))
              (= (to_rep (select a temp___idx_168)) (to_rep
                                                      (select b (+ (- b__first a__first) temp___idx_168)))))))))))

(declare-sort us_rep 0)

(declare-const value__size Int)

(declare-const object__size Int)

(declare-const alignment Int)

;; "value__size_axiom"
(assert (<= 0 value__size))

;; "object__size_axiom"
(assert (<= 0 object__size))

;; "alignment_axiom"
(assert (<= 0 alignment))

(declare-const dummy us_rep)

;; "mem"
(declare-fun mem (us_rep
  Int) Bool)

;; "mem__function_guard"
(declare-fun mem__function_guard (Bool
  us_rep
  Int) Bool)

;; "in_range"
(define-fun in_range1 ((x Int)) Bool
  (and (<= 0 x) (<= x 3)))

;; "is_empty"
(declare-fun is_empty (us_rep) Bool)

;; "is_empty__function_guard"
(declare-fun is_empty__function_guard (Bool
  us_rep) Bool)

;; "is_add"
(declare-fun is_add (us_rep
  Int
  us_rep) Bool)

;; "is_add__function_guard"
(declare-fun is_add__function_guard (Bool
  us_rep
  Int
  us_rep) Bool)

(declare-datatypes ((us_split_fields 0))
  (((us_split_fieldsqtmk
    (rec__allocator__m__t__available us_rep)(rec__allocator__m__t__allocated us_rep)))))

(declare-datatypes ((us_rep1 0))
  (((us_repqtmk (us_split_fields1 us_split_fields)))))

(declare-const value__size1 Int)

(declare-const object__size1 Int)

(declare-const alignment1 Int)

;; "value__size_axiom"
(assert (<= 0 value__size1))

;; "object__size_axiom"
(assert (<= 0 object__size1))

;; "alignment_axiom"
(assert (<= 0 alignment1))

(declare-const allocator__m__t__available__first__bit Int)

(declare-const allocator__m__t__available__last__bit Int)

(declare-const allocator__m__t__available__position Int)

;; "allocator__m__t__available__first__bit_axiom"
(assert (<= 0 allocator__m__t__available__first__bit))

;; "allocator__m__t__available__last__bit_axiom"
(assert
  (< allocator__m__t__available__first__bit allocator__m__t__available__last__bit))

;; "allocator__m__t__available__position_axiom"
(assert (<= 0 allocator__m__t__available__position))

(declare-const allocator__m__t__allocated__first__bit Int)

(declare-const allocator__m__t__allocated__last__bit Int)

(declare-const allocator__m__t__allocated__position Int)

;; "allocator__m__t__allocated__first__bit_axiom"
(assert (<= 0 allocator__m__t__allocated__first__bit))

;; "allocator__m__t__allocated__last__bit_axiom"
(assert
  (< allocator__m__t__allocated__first__bit allocator__m__t__allocated__last__bit))

;; "allocator__m__t__allocated__position_axiom"
(assert (<= 0 allocator__m__t__allocated__position))

(declare-const dummy1 us_rep1)

;; "oeq"
(declare-fun oeq (us_rep1
  us_rep1) Bool)

;; "oeq"
(declare-fun oeq1 (us_rep
  us_rep) Bool)

;; "oeq__function_guard"
(declare-fun oeq__function_guard (Bool
  us_rep
  us_rep) Bool)

;; "model"
(declare-fun model1 ((Array Int status)) us_rep1)

;; "model__function_guard"
(declare-fun model__function_guard (us_rep1
  (Array Int status)) Bool)

;; "is_valid"
(declare-fun is_valid (us_rep1
  (Array Int status)) Bool)

;; "in_range"
(define-fun in_range2 ((x Int)) Bool
  (and (<= 1 x) (<= x 3)))

(declare-const value__size2 Int)

(declare-const object__size2 Int)

(declare-const component__size Int)

(declare-const alignment2 Int)

;; "value__size_axiom"
(assert (<= 0 value__size2))

;; "object__size_axiom"
(assert (<= 0 object__size2))

;; "component__size_axiom"
(assert (<= 0 component__size))

;; "alignment_axiom"
(assert (<= 0 alignment2))

;; "mem__post_axiom"
(assert
  (forall ((param__s us_rep))
    (forall ((param__e Int))
      (! (=>
           (in_range1 param__e)
           (let ((result (mem param__s param__e)))
             (=>
               (mem__function_guard result param__s param__e)
               (=> (= param__e 0) (not (= result true)))))) :pattern (
      (mem
        param__s
        param__e)) ))))

;; "oeq__post_axiom"
(assert
  (forall ((param__s1 us_rep) (param__s2 us_rep))
    (! (let ((result (oeq1 param__s1 param__s2)))
         (=>
           (oeq__function_guard result param__s1 param__s2)
           (and
             (forall ((e Int))
               (mem__function_guard (mem param__s1 e) param__s1 e))
             (and
               (forall ((e Int))
                 (mem__function_guard (mem param__s2 e) param__s2 e))
               (and
                 (forall ((e Int))
                   (mem__function_guard (mem param__s2 e) param__s2 e))
                 (and
                   (forall ((e Int))
                     (mem__function_guard (mem param__s1 e) param__s1 e))
                   (=
                     (= result true)
                     (and
                       (forall ((e Int))
                         (=>
                           (and (in_range1 e) (= (mem param__s1 e) true))
                           (= (let ((temp___257qtunused param__s2))
                                (mem param__s2 e)) true)))
                       (forall ((e Int))
                         (=>
                           (and (in_range1 e) (= (mem param__s2 e) true))
                           (= (let ((temp___262qtunused param__s1))
                                (mem param__s1 e)) true))))))))))) :pattern (
    (oeq1
      param__s1
      param__s2)) )))

;; "is_add__post_axiom"
(assert
  (forall ((param__s us_rep) (param__result__ us_rep))
    (forall ((param__e Int))
      (! (=>
           (in_range1 param__e)
           (let ((result (is_add param__s param__e param__result__)))
             (=>
               (is_add__function_guard
                 result
                 param__s
                 param__e
                 param__result__)
               (and
                 (mem__function_guard
                   (mem param__result__ param__e)
                   param__result__
                   param__e)
                 (and
                   (mem__function_guard
                     (mem param__s param__e)
                     param__s
                     param__e)
                   (and
                     (forall ((f Int))
                       (mem__function_guard
                         (mem param__result__ f)
                         param__result__
                         f))
                     (and
                       (forall ((f Int))
                         (mem__function_guard (mem param__s f) param__s f))
                       (and
                         (forall ((e Int))
                           (mem__function_guard (mem param__s e) param__s e))
                         (and
                           (forall ((e Int))
                             (mem__function_guard
                               (mem param__result__ e)
                               param__result__
                               e))
                           (=
                             (= result true)
                             (and
                               (and
                                 (and
                                   (and
                                     (not (= param__e 0))
                                     (= (let ((temp___284qtunused param__result__))
                                          (mem param__result__ param__e)) true))
                                   (not
                                     (= (let ((temp___286qtunused param__s))
                                          (mem param__s param__e)) true)))
                                 (forall ((f Int))
                                   (=>
                                     (and
                                       (in_range1 f)
                                       (= (mem param__result__ f) true))
                                     (or
                                       (= (let ((temp___291qtunused param__s))
                                            (mem param__s f)) true)
                                       (= f param__e)))))
                               (forall ((e Int))
                                 (=>
                                   (and
                                     (in_range1 e)
                                     (= (mem param__s e) true))
                                   (= (let ((temp___296qtunused param__result__))
                                        (mem param__result__ e)) true)))))))))))))) :pattern (
      (is_add
        param__s
        param__e
        param__result__)) ))))

;; "oeq__post_axiom"
(assert true)

;; "oeq__def_axiom"
(assert
  (forall ((param__x us_rep1) (param__y us_rep1))
    (! (and
         (forall ((temp___412 us_rep) (temp___411 us_rep))
           (oeq__function_guard
             (oeq1 temp___411 temp___412)
             temp___411
             temp___412))
         (and
           (forall ((temp___415 us_rep) (temp___414 us_rep))
             (oeq__function_guard
               (oeq1 temp___414 temp___415)
               temp___414
               temp___415))
           (=
             (= (oeq param__x param__y) true)
             (and
               (= (let ((temp___412 (rec__allocator__m__t__available
                                      (us_split_fields1 param__y))))
                    (let ((temp___411 (rec__allocator__m__t__available
                                        (us_split_fields1 param__x))))
                      (oeq1 temp___411 temp___412))) true)
               (= (let ((temp___415 (rec__allocator__m__t__allocated
                                      (us_split_fields1 param__y))))
                    (let ((temp___414 (rec__allocator__m__t__allocated
                                        (us_split_fields1 param__x))))
                      (oeq1 temp___414 temp___415))) true))))) :pattern (
    (oeq
      param__x
      param__y)) )))

;; "is_valid__post_axiom"
(assert true)

;; "is_valid__def_axiom"
(assert
  (forall ((param__m us_rep1))
    (forall ((Allocator__data___data___ (Array Int status)))
      (! (and
           (forall ((temp___436 us_rep) (e Int))
             (mem__function_guard (mem temp___436 e) temp___436 e))
           (and
             (forall ((temp___439 us_rep) (e Int))
               (mem__function_guard (mem temp___439 e) temp___439 e))
             (and
               (forall ((r Int) (temp___444 us_rep))
                 (mem__function_guard (mem temp___444 r) temp___444 r))
               (and
                 (forall ((r Int) (temp___447 us_rep))
                   (mem__function_guard (mem temp___447 r) temp___447 r))
                 (and
                   (forall ((r Int) (temp___450 us_rep))
                     (mem__function_guard (mem temp___450 r) temp___450 r))
                   (and
                     (forall ((r Int) (temp___453 us_rep))
                       (mem__function_guard (mem temp___453 r) temp___453 r))
                     (=
                       (= (is_valid param__m Allocator__data___data___) true)
                       (and
                         (and
                           (forall ((e Int))
                             (=>
                               (and
                                 (in_range1 e)
                                 (= (mem
                                      (rec__allocator__m__t__available
                                        (us_split_fields1 param__m))
                                      e) true))
                               (in_range2 e)))
                           (forall ((e Int))
                             (=>
                               (and
                                 (in_range1 e)
                                 (= (mem
                                      (rec__allocator__m__t__allocated
                                        (us_split_fields1 param__m))
                                      e) true))
                               (in_range2 e))))
                         (forall ((r Int))
                           (=>
                             (and (<= 1 r) (<= r 3))
                             (ite (= (to_rep
                                       (select Allocator__data___data___ r)) 0)
                               (and
                                 (= (let ((temp___445qtunused r))
                                      (let ((temp___444 (rec__allocator__m__t__available
                                                          (us_split_fields1
                                                            param__m))))
                                        (mem temp___444 r))) true)
                                 (not
                                   (= (let ((temp___448qtunused r))
                                        (let ((temp___447 (rec__allocator__m__t__allocated
                                                            (us_split_fields1
                                                              param__m))))
                                          (mem temp___447 r))) true)))
                               (and
                                 (not
                                   (= (let ((temp___451qtunused r))
                                        (let ((temp___450 (rec__allocator__m__t__available
                                                            (us_split_fields1
                                                              param__m))))
                                          (mem temp___450 r))) true))
                                 (= (let ((temp___454qtunused r))
                                      (let ((temp___453 (rec__allocator__m__t__allocated
                                                          (us_split_fields1
                                                            param__m))))
                                        (mem temp___453 r))) true))))))))))))) :pattern (
      (is_valid
        param__m
        Allocator__data___data___)) ))))

;; "model__post_axiom"
(assert
  (forall ((Allocator__data___data___ (Array Int status)))
    (! (let ((result (model1 Allocator__data___data___)))
         (=>
           (model__function_guard result Allocator__data___data___)
           (= (is_valid result Allocator__data___data___) true))) :pattern (
    (model1
      Allocator__data___data___)) )))

;; Goal "def'vc"
;; File "allocator.ads", line 49, characters 0-0
(assert
  (not
  (forall ((data (Array Int status)) (res Int))
    (=>
      (in_range1 res)
      (let ((o (model1 data)))
        (=>
          (and (model__function_guard o data) (= (is_valid o data) true))
          (let ((o1 (rec__allocator__m__t__available (us_split_fields1 o))))
            (let ((temp___596 (is_empty o1)))
              (=>
                (forall ((o2 us_rep) (e Int))
                  (mem__function_guard (mem o2 e) o2 e))
                (=>
                  (and
                    (is_empty__function_guard temp___596 o1)
                    (=
                      (= temp___596 true)
                      (forall ((e Int))
                        (not (and (in_range1 e) (= (mem o1 e) true))))))
                  (=>
                    (model__function_guard (model1 data) data)
                    (let ((temp___result_621 (model1 data)))
                      (=>
                        (model__function_guard temp___result_621 data)
                        (let ((temp___result_620 (model1 data)))
                          (=>
                            (model__function_guard temp___result_620 data)
                            (forall ((data1 (Array Int status)) (res1 Int))
                              (=>
                                (or
                                  (exists ((r Int))
                                    (and
                                      (= r 1)
                                      (and
                                        (= (and (ite (<= 1 r) true false) 
                                        (ite (<= r 3)
                                          true
                                          false)) true)
                                        (exists ((o2 Int))
                                          (and
                                            (= (to_rep (select data r)) o2)
                                            (exists ((spark__branch Bool))
                                              (and
                                                (= spark__branch (ite (= o2 0)
                                                                   true
                                                                   false))
                                                (ite (= spark__branch true)
                                                  (exists ((o3 status))
                                                    (and
                                                      (= (to_rep o3) 1)
                                                      (and
                                                        (= data1 (store data r o3))
                                                        (= res1 r))))
                                                  (exists ((data2 (Array Int status)) (res2 Int) (r1 Int))
                                                    (and
                                                      (and
                                                        (= (bool_eq
                                                             data2
                                                             1
                                                             3
                                                             data
                                                             1
                                                             3) true)
                                                        (forall ((rr Int))
                                                          (=>
                                                            (and
                                                              (<= 1 rr)
                                                              (<= rr r1))
                                                            (= (to_rep
                                                                 (select data2 rr)) 1))))
                                                      (and
                                                        (= (and (ite 
                                                                  (and
                                                                    (= data2 data)
                                                                    (= res2 res))
                                                                  true
                                                                  false) 
                                                        (ite (and
                                                               (<= 1 r1)
                                                               (<= r1 3))
                                                          true
                                                          false)) true)
                                                        (and
                                                          (not (= r1 3))
                                                          (exists ((r2 Int))
                                                            (and
                                                              (= r2 (+ r1 1))
                                                              (exists 
                                                                ((o3 Int))
                                                                (and
                                                                  (= 
                                                                  (to_rep
                                                                    (select data2 r2)) o3)
                                                                  (exists 
                                                                    ((spark__branch1 Bool))
                                                                    (and
                                                                    (= spark__branch1 
                                                                    (ite (= o3 0)
                                                                    true
                                                                    false))
                                                                    (and
                                                                    (= spark__branch1 true)
                                                                    (exists 
                                                                    ((o4 status))
                                                                    (and
                                                                    (= 
                                                                    (to_rep
                                                                    o4) 1)
                                                                    (and
                                                                    (= data1 (store data2 r2 o4))
                                                                    (= res1 r2)))))))))))))))))))))))
                                  (exists ((res2 Int))
                                    (and
                                      (exists ((r Int))
                                        (and
                                          (= r 1)
                                          (ite (= (and (ite (<= 1 r)
                                                         true
                                                         false) (ite (<= r 3)
                                                                  true
                                                                  false)) true)
                                            (exists ((o2 Int))
                                              (and
                                                (= (to_rep (select data r)) o2)
                                                (exists ((spark__branch Bool))
                                                  (and
                                                    (= spark__branch 
                                                    (ite (= o2 0)
                                                      true
                                                      false))
                                                    (and
                                                      (not
                                                        (= spark__branch true))
                                                      (exists ((r1 Int))
                                                        (and
                                                          (and
                                                            (= (bool_eq
                                                                 data1
                                                                 1
                                                                 3
                                                                 data
                                                                 1
                                                                 3) true)
                                                            (forall ((rr Int))
                                                              (=>
                                                                (and
                                                                  (<= 1 rr)
                                                                  (<= rr r1))
                                                                (= (to_rep
                                                                    (select data1 rr)) 1))))
                                                          (and
                                                            (= (and (ite 
                                                                    (and
                                                                    (= data1 data)
                                                                    (= res2 res))
                                                                    true
                                                                    false) 
                                                            (ite (and
                                                                   (<= 1 r1)
                                                                   (<= r1 3))
                                                              true
                                                              false)) true)
                                                            (= r1 3)))))))))
                                            (and (= data1 data) (= res2 res)))))
                                      (= res1 0))))
                                (=>
                                  (model__function_guard
                                    (model1 data1)
                                    data1)
                                  (=>
                                    (=>
                                      (= temp___596 true)
                                      (and
                                        (= res1 0)
                                        (= (oeq
                                             (model1 data1)
                                             temp___result_620) true)))
                                    (=>
                                      (not (= temp___596 true))
                                      (=>
                                        (model__function_guard
                                          (model1 data1)
                                          data1)
                                        (=>
                                          (forall ((temp___old_610 us_rep) (temp___614 us_rep))
                                            (is_add__function_guard
                                              (is_add
                                                temp___614
                                                res1
                                                temp___old_610)
                                              temp___614
                                              res1
                                              temp___old_610))
                                          (= (let ((temp___614 (rec__allocator__m__t__available
                                                                 (us_split_fields1
                                                                   (model1
                                                                    data1)))))
                                               (is_add
                                                 temp___614
                                                 res1
                                                 (rec__allocator__m__t__available
                                                   (us_split_fields1
                                                     temp___result_621)))) true)))))))))))))))))))))))

(check-sat)
(get-info :reason-unknown)
