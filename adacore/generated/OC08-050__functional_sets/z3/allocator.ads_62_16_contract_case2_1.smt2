;; produced by z3_gnatprove.drv ;;
(set-info :smt-lib-version 2.5)
(set-info :source |VC generated by SPARK 2014|)
(set-info :category industrial)
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort us_private 0)

(declare-const us_null_ext__ us_private)

(declare-datatypes ()
  ((int__ref (int__refqtmk (int__content Int)))))

(declare-datatypes ()
  ((bool__ref (bool__refqtmk (bool__content Bool)))))

(declare-sort status 0)

;; "in_range"
(define-fun in_range ((x Int)) Bool
  (and (<= 0 x) (<= x 1)))

;; "to_rep"
(declare-fun to_rep (status) Int)

;; "of_rep"
(declare-fun of_rep (Int) status)

;; "inversion_axiom"
(assert
  (forall ((x status)) (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; "range_axiom"
(assert
  (forall ((x status)) (! (in_range (to_rep x)) :pattern ((to_rep x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                               (of_rep x))) )))

(declare-datatypes ()
  ((map__ref (map__refqtmk (map__content (Array Int status))))))

;; "bool_eq"
(define-fun bool_eq ((a (Array Int status)) (a__first Int) (a__last Int) (b (Array Int status)) (b__first Int) (b__last Int)) Bool
  (ite (and
         (ite (<= a__first a__last)
           (and
             (<= b__first b__last)
             (= (- a__last a__first) (- b__last b__first)))
           (< b__last b__first))
         (forall ((temp___idx_168 Int))
           (=>
             (and (<= a__first temp___idx_168) (<= temp___idx_168 a__last))
             (= (to_rep (select a temp___idx_168)) (to_rep
                                                     (select b (+ (- b__first a__first) temp___idx_168)))))))
    true
    false))

;; "bool_eq_rev"
(assert
  (forall ((a (Array Int status)) (b (Array Int status)))
    (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
      (=>
        (= (bool_eq b b__first b__last a a__first a__last) true)
        (and
          (ite (<= a__first a__last)
            (and
              (<= b__first b__last)
              (= (- a__last a__first) (- b__last b__first)))
            (< b__last b__first))
          (forall ((temp___idx_168 Int))
            (=>
              (and (<= a__first temp___idx_168) (<= temp___idx_168 a__last))
              (= (to_rep (select a temp___idx_168)) (to_rep
                                                      (select b (+ (- b__first a__first) temp___idx_168)))))))))))

(declare-sort us_rep 0)

(declare-const value__size Int)

(declare-const object__size Int)

(declare-const alignment Int)

;; "value__size_axiom"
(assert (<= 0 value__size))

;; "object__size_axiom"
(assert (<= 0 object__size))

;; "alignment_axiom"
(assert (<= 0 alignment))

(declare-const dummy us_rep)

;; "mem"
(declare-fun mem (us_rep
  Int) Bool)

;; "mem__function_guard"
(declare-fun mem__function_guard (Bool
  us_rep
  Int) Bool)

;; "in_range"
(define-fun in_range1 ((x Int)) Bool
  (and (<= 0 x) (<= x 3)))

;; "is_empty"
(declare-fun is_empty (us_rep) Bool)

;; "is_empty__function_guard"
(declare-fun is_empty__function_guard (Bool
  us_rep) Bool)

;; "is_add"
(declare-fun is_add (us_rep
  Int
  us_rep) Bool)

;; "is_add__function_guard"
(declare-fun is_add__function_guard (Bool
  us_rep
  Int
  us_rep) Bool)

(declare-datatypes ()
  ((us_split_fields
   (us_split_fieldsqtmk
   (rec__allocator__m__t__available us_rep)(rec__allocator__m__t__allocated us_rep)))))

(declare-datatypes ()
  ((us_rep1 (us_repqtmk (us_split_fields1 us_split_fields)))))

(declare-const value__size1 Int)

(declare-const object__size1 Int)

(declare-const alignment1 Int)

;; "value__size_axiom"
(assert (<= 0 value__size1))

;; "object__size_axiom"
(assert (<= 0 object__size1))

;; "alignment_axiom"
(assert (<= 0 alignment1))

(declare-const allocator__m__t__available__first__bit Int)

(declare-const allocator__m__t__available__last__bit Int)

(declare-const allocator__m__t__available__position Int)

;; "allocator__m__t__available__first__bit_axiom"
(assert (<= 0 allocator__m__t__available__first__bit))

;; "allocator__m__t__available__last__bit_axiom"
(assert
  (< allocator__m__t__available__first__bit allocator__m__t__available__last__bit))

;; "allocator__m__t__available__position_axiom"
(assert (<= 0 allocator__m__t__available__position))

(declare-const allocator__m__t__allocated__first__bit Int)

(declare-const allocator__m__t__allocated__last__bit Int)

(declare-const allocator__m__t__allocated__position Int)

;; "allocator__m__t__allocated__first__bit_axiom"
(assert (<= 0 allocator__m__t__allocated__first__bit))

;; "allocator__m__t__allocated__last__bit_axiom"
(assert
  (< allocator__m__t__allocated__first__bit allocator__m__t__allocated__last__bit))

;; "allocator__m__t__allocated__position_axiom"
(assert (<= 0 allocator__m__t__allocated__position))

(declare-const dummy1 us_rep1)

;; "oeq"
(declare-fun oeq (us_rep1
  us_rep1) Bool)

;; "oeq"
(declare-fun oeq1 (us_rep
  us_rep) Bool)

;; "oeq__function_guard"
(declare-fun oeq__function_guard (Bool
  us_rep
  us_rep) Bool)

;; "model"
(declare-fun model1 ((Array Int status)) us_rep1)

;; "model__function_guard"
(declare-fun model__function_guard (us_rep1
  (Array Int status)) Bool)

;; "is_valid"
(declare-fun is_valid (us_rep1
  (Array Int status)) Bool)

;; "in_range"
(define-fun in_range2 ((x Int)) Bool
  (and (<= 1 x) (<= x 3)))

(declare-const value__size2 Int)

(declare-const object__size2 Int)

(declare-const component__size Int)

(declare-const alignment2 Int)

;; "value__size_axiom"
(assert (<= 0 value__size2))

;; "object__size_axiom"
(assert (<= 0 object__size2))

;; "component__size_axiom"
(assert (<= 0 component__size))

;; "alignment_axiom"
(assert (<= 0 alignment2))

;; "mem__post_axiom"
(assert
  (forall ((param__s us_rep))
    (forall ((param__e Int))
      (! (=>
           (in_range1 param__e)
           (let ((result (mem param__s param__e)))
             (=>
               (mem__function_guard result param__s param__e)
               (=> (= param__e 0) (not (= result true)))))) :pattern (
      (mem
        param__s
        param__e)) ))))

;; "oeq__post_axiom"
(assert
  (forall ((param__s1 us_rep) (param__s2 us_rep))
    (! (let ((result (oeq1 param__s1 param__s2)))
         (and
           (forall ((e Int) (temp___255 us_rep))
             (mem__function_guard (mem temp___255 e) temp___255 e))
           (and
             (forall ((e Int) (temp___257 us_rep))
               (mem__function_guard (mem temp___257 e) temp___257 e))
             (and
               (forall ((e Int) (temp___260 us_rep))
                 (mem__function_guard (mem temp___260 e) temp___260 e))
               (and
                 (forall ((e Int) (temp___262 us_rep))
                   (mem__function_guard (mem temp___262 e) temp___262 e))
                 (=>
                   (oeq__function_guard result param__s1 param__s2)
                   (=
                     (= result true)
                     (and
                       (forall ((e Int))
                         (=>
                           (and (in_range1 e) (= (mem param__s1 e) true))
                           (= (let ((temp___257 param__s2))
                                (mem temp___257 e)) true)))
                       (forall ((e Int))
                         (=>
                           (and (in_range1 e) (= (mem param__s2 e) true))
                           (= (let ((temp___262 param__s1))
                                (mem temp___262 e)) true))))))))))) :pattern (
    (oeq1
      param__s1
      param__s2)) )))

;; "is_add__post_axiom"
(assert
  (forall ((param__s us_rep) (param__result__ us_rep))
    (forall ((param__e Int))
      (! (=>
           (in_range1 param__e)
           (let ((result (is_add param__s param__e param__result__)))
             (and
               (forall ((temp___284 us_rep))
                 (mem__function_guard
                   (mem temp___284 param__e)
                   temp___284
                   param__e))
               (and
                 (forall ((temp___286 us_rep))
                   (mem__function_guard
                     (mem temp___286 param__e)
                     temp___286
                     param__e))
                 (and
                   (forall ((f Int) (temp___289 us_rep))
                     (mem__function_guard (mem temp___289 f) temp___289 f))
                   (and
                     (forall ((f Int) (temp___291 us_rep))
                       (mem__function_guard (mem temp___291 f) temp___291 f))
                     (and
                       (forall ((e Int) (temp___294 us_rep))
                         (mem__function_guard
                           (mem temp___294 e)
                           temp___294
                           e))
                       (and
                         (forall ((e Int) (temp___296 us_rep))
                           (mem__function_guard
                             (mem temp___296 e)
                             temp___296
                             e))
                         (=>
                           (is_add__function_guard
                             result
                             param__s
                             param__e
                             param__result__)
                           (=
                             (= result true)
                             (and
                               (and
                                 (and
                                   (and
                                     (not (= param__e 0))
                                     (= (let ((temp___284 param__result__))
                                          (mem temp___284 param__e)) true))
                                   (not
                                     (= (let ((temp___286 param__s))
                                          (mem temp___286 param__e)) true)))
                                 (forall ((f Int))
                                   (=>
                                     (and
                                       (in_range1 f)
                                       (= (mem param__result__ f) true))
                                     (or
                                       (= (let ((temp___291 param__s))
                                            (mem temp___291 f)) true)
                                       (= f param__e)))))
                               (forall ((e Int))
                                 (=>
                                   (and
                                     (in_range1 e)
                                     (= (mem param__s e) true))
                                   (= (let ((temp___296 param__result__))
                                        (mem temp___296 e)) true)))))))))))))) :pattern (
      (is_add
        param__s
        param__e
        param__result__)) ))))

;; "oeq__post_axiom"
(assert true)

;; "oeq__def_axiom"
(assert
  (forall ((param__x us_rep1) (param__y us_rep1))
    (! (and
         (forall ((temp___412 us_rep) (temp___411 us_rep))
           (oeq__function_guard
             (oeq1 temp___411 temp___412)
             temp___411
             temp___412))
         (and
           (forall ((temp___415 us_rep) (temp___414 us_rep))
             (oeq__function_guard
               (oeq1 temp___414 temp___415)
               temp___414
               temp___415))
           (=
             (= (oeq param__x param__y) true)
             (and
               (= (let ((temp___412 (rec__allocator__m__t__available
                                      (us_split_fields1 param__y))))
                    (let ((temp___411 (rec__allocator__m__t__available
                                        (us_split_fields1 param__x))))
                      (oeq1 temp___411 temp___412))) true)
               (= (let ((temp___415 (rec__allocator__m__t__allocated
                                      (us_split_fields1 param__y))))
                    (let ((temp___414 (rec__allocator__m__t__allocated
                                        (us_split_fields1 param__x))))
                      (oeq1 temp___414 temp___415))) true))))) :pattern (
    (oeq
      param__x
      param__y)) )))

;; "is_valid__post_axiom"
(assert true)

;; "is_valid__def_axiom"
(assert
  (forall ((param__m us_rep1))
    (forall ((Allocator__data___data___ (Array Int status)))
      (! (and
           (forall ((e Int) (temp___438 us_rep))
             (mem__function_guard (mem temp___438 e) temp___438 e))
           (and
             (forall ((e Int) (temp___441 us_rep))
               (mem__function_guard (mem temp___441 e) temp___441 e))
             (and
               (forall ((temp___445 Int) (temp___444 us_rep))
                 (mem__function_guard
                   (mem temp___444 temp___445)
                   temp___444
                   temp___445))
               (and
                 (forall ((temp___448 Int) (temp___447 us_rep))
                   (mem__function_guard
                     (mem temp___447 temp___448)
                     temp___447
                     temp___448))
                 (and
                   (forall ((temp___451 Int) (temp___450 us_rep))
                     (mem__function_guard
                       (mem temp___450 temp___451)
                       temp___450
                       temp___451))
                   (and
                     (forall ((temp___454 Int) (temp___453 us_rep))
                       (mem__function_guard
                         (mem temp___453 temp___454)
                         temp___453
                         temp___454))
                     (=
                       (= (is_valid param__m Allocator__data___data___) true)
                       (and
                         (and
                           (forall ((e Int))
                             (=>
                               (and
                                 (in_range1 e)
                                 (= (mem
                                      (rec__allocator__m__t__available
                                        (us_split_fields1 param__m))
                                      e) true))
                               (in_range2 e)))
                           (forall ((e Int))
                             (=>
                               (and
                                 (in_range1 e)
                                 (= (mem
                                      (rec__allocator__m__t__allocated
                                        (us_split_fields1 param__m))
                                      e) true))
                               (in_range2 e))))
                         (forall ((r Int))
                           (=>
                             (and (<= 1 r) (<= r 3))
                             (ite (= (to_rep
                                       (select Allocator__data___data___ r)) 0)
                               (and
                                 (= (let ((temp___445 r))
                                      (let ((temp___444 (rec__allocator__m__t__available
                                                          (us_split_fields1
                                                            param__m))))
                                        (mem temp___444 temp___445))) true)
                                 (not
                                   (= (let ((temp___448 r))
                                        (let ((temp___447 (rec__allocator__m__t__allocated
                                                            (us_split_fields1
                                                              param__m))))
                                          (mem temp___447 temp___448))) true)))
                               (and
                                 (not
                                   (= (let ((temp___451 r))
                                        (let ((temp___450 (rec__allocator__m__t__available
                                                            (us_split_fields1
                                                              param__m))))
                                          (mem temp___450 temp___451))) true))
                                 (= (let ((temp___454 r))
                                      (let ((temp___453 (rec__allocator__m__t__allocated
                                                          (us_split_fields1
                                                            param__m))))
                                        (mem temp___453 temp___454))) true))))))))))))) :pattern (
      (is_valid
        param__m
        Allocator__data___data___)) ))))

;; "model__post_axiom"
(assert
  (forall ((Allocator__data___data___ (Array Int status)))
    (! (let ((result (model1 Allocator__data___data___)))
         (=>
           (model__function_guard result Allocator__data___data___)
           (= (is_valid result Allocator__data___data___) true))) :pattern (
    (model1
      Allocator__data___data___)) )))

(declare-const data (Array Int status))

(declare-const res Int)

;; "res'unused"
(define-fun resqtunused () int__ref
  (int__refqtmk res))

;; "data'unused"
(define-fun dataqtunused () map__ref
  (map__refqtmk data))

;; "Assume"
(assert true)

;; "Assume"
(assert (in_range1 res))

;; "o"
(define-fun o () us_rep1
  (model1 data))

;; "H"
(assert (model__function_guard o data))

;; "H"
(assert true)

;; "H"
(assert (= (is_valid o data) true))

;; "model'result'unused"
(define-fun modelqtresultqtunused () us_rep1
  o)

;; "o"
(define-fun o1 () us_split_fields
  (us_split_fields1 o))

;; "__split_fields'result'unused"
(define-fun us_split_fieldsqtresultqtunused () us_split_fields
  o1)

;; "o"
(define-fun o2 () us_rep
  (rec__allocator__m__t__available o1))

;; "rec__allocator__m__t__available'result'unused"
(define-fun rec__allocator__m__t__availableqtresultqtunused () us_rep
  o2)

;; "temp___596"
(define-fun temp___596 () Bool
  (is_empty o2))

;; "H"
(assert (forall ((o3 us_rep) (e Int)) (mem__function_guard (mem o3 e) o3 e)))

;; "H"
(assert (is_empty__function_guard temp___596 o2))

;; "H"
(assert
  (=
    (= temp___596 true)
    (forall ((e Int)) (not (and (in_range1 e) (= (mem o2 e) true))))))

;; "is_empty'result'unused"
(define-fun is_emptyqtresultqtunused () Bool
  temp___596)

;; "map__content'result'unused"
(define-fun map__contentqtresultqtunused () (Array Int status)
  data)

;; "temp___result_622"
(define-fun temp___result_622 () us_rep1
  (model1 data))

;; "model'result'unused"
(define-fun modelqtresultqtunused1 () us_rep1
  temp___result_622)

;; "Assume"
(assert (model__function_guard temp___result_622 data))

;; "o"
(define-fun o3 () us_split_fields
  (us_split_fields1 temp___result_622))

;; "__split_fields'result'unused"
(define-fun us_split_fieldsqtresultqtunused1 () us_split_fields
  o3)

;; "temp___old_611"
(define-fun temp___old_611 () us_rep
  (rec__allocator__m__t__allocated o3))

;; "rec__allocator__m__t__allocated'result'unused"
(define-fun rec__allocator__m__t__allocatedqtresultqtunused () us_rep
  temp___old_611)

;; "map__content'result'unused"
(define-fun map__contentqtresultqtunused1 () (Array Int status)
  data)

;; "temp___result_621"
(define-fun temp___result_621 () us_rep1
  (model1 data))

;; "model'result'unused"
(define-fun modelqtresultqtunused2 () us_rep1
  temp___result_621)

;; "Assume"
(assert (model__function_guard temp___result_621 data))

;; "o"
(define-fun o4 () us_split_fields
  (us_split_fields1 temp___result_621))

;; "__split_fields'result'unused"
(define-fun us_split_fieldsqtresultqtunused2 () us_split_fields
  o4)

;; "temp___old_610"
(define-fun temp___old_610 () us_rep
  (rec__allocator__m__t__available o4))

;; "rec__allocator__m__t__available'result'unused"
(define-fun rec__allocator__m__t__availableqtresultqtunused1 () us_rep
  temp___old_610)

;; "map__content'result'unused"
(define-fun map__contentqtresultqtunused2 () (Array Int status)
  data)

;; "temp___result_620"
(define-fun temp___result_620 () us_rep1
  (model1 data))

;; "model'result'unused"
(define-fun modelqtresultqtunused3 () us_rep1
  temp___result_620)

;; "Assume"
(assert (model__function_guard temp___result_620 data))

(declare-const data1 (Array Int status))

(declare-const res1 Int)

;; "res'unused"
(define-fun resqtunused1 () int__ref
  (int__refqtmk res1))

;; "data'unused"
(define-fun dataqtunused1 () map__ref
  (map__refqtmk data1))

;; "H"
(assert
  (or
    (exists ((r Int))
      (and
        (= r 1)
        (and
          (= (and (ite (<= 1 r) true false) (ite (<= r 3) true false)) true)
          (exists ((o5 Int))
            (and
              (= (to_rep (select data r)) o5)
              (exists ((spark__branch Bool))
                (and
                  (= spark__branch (ite (= o5 0) true false))
                  (ite (= spark__branch true)
                    (exists ((o6 status))
                      (and
                        (= (to_rep o6) 1)
                        (and (= data1 (store data r o6)) (= res1 r))))
                    (exists ((data2 (Array Int status)) (res2 Int) (r1 Int))
                      (and
                        (and
                          (= (bool_eq data2 1 3 data 1 3) true)
                          (forall ((rr Int))
                            (=>
                              (and (<= 1 rr) (<= rr r1))
                              (= (to_rep (select data2 rr)) 1))))
                        (and
                          (= (and (ite (and (= data2 data) (= res2 res))
                                    true
                                    false) (ite (and (<= 1 r1) (<= r1 3))
                                             true
                                             false)) true)
                          (and
                            (not (= r1 3))
                            (exists ((r2 Int))
                              (and
                                (= r2 (+ r1 1))
                                (exists ((o6 Int))
                                  (and
                                    (= (to_rep (select data2 r2)) o6)
                                    (exists ((spark__branch1 Bool))
                                      (and
                                        (= spark__branch1 (ite (= o6 0)
                                                            true
                                                            false))
                                        (and
                                          (= spark__branch1 true)
                                          (exists ((o7 status))
                                            (and
                                              (= (to_rep o7) 1)
                                              (and
                                                (= data1 (store data2 r2 o7))
                                                (= res1 r2)))))))))))))))))))))))
    (exists ((res2 Int))
      (and
        (exists ((r Int))
          (and
            (= r 1)
            (ite (= (and (ite (<= 1 r) true false) (ite (<= r 3) true false)) true)
              (exists ((o5 Int))
                (and
                  (= (to_rep (select data r)) o5)
                  (exists ((spark__branch Bool))
                    (and
                      (= spark__branch (ite (= o5 0) true false))
                      (and
                        (not (= spark__branch true))
                        (exists ((r1 Int))
                          (and
                            (and
                              (= (bool_eq data1 1 3 data 1 3) true)
                              (forall ((rr Int))
                                (=>
                                  (and (<= 1 rr) (<= rr r1))
                                  (= (to_rep (select data1 rr)) 1))))
                            (and
                              (= (and (ite (and (= data1 data) (= res2 res))
                                        true
                                        false) (ite (and (<= 1 r1) (<= r1 3))
                                                 true
                                                 false)) true)
                              (= r1 3)))))))))
              (and (= data1 data) (= res2 res)))))
        (= res1 0)))))

;; "H"
(assert (model__function_guard (model1 data1) data1))

;; "Assert"
(assert
  (=>
    (= temp___596 true)
    (and (= res1 0) (= (oeq (model1 data1) temp___result_620) true))))

;; "H"
(assert (not (= temp___596 true)))

;; "H"
(assert (model__function_guard (model1 data1) data1))

;; "H"
(assert
  (forall ((temp___old_6111 us_rep) (temp___619 us_rep))
    (is_add__function_guard
      (is_add temp___old_6111 res1 temp___619)
      temp___old_6111
      res1
      temp___619)))

;; Goal "def'vc"
;; File "allocator.ads", line 49, characters 0-0
(assert
  (not
  (= (let ((temp___619 (rec__allocator__m__t__allocated
                         (us_split_fields1 (model1 data1)))))
       (is_add temp___old_611 res1 temp___619)) true)))

(check-sat)
