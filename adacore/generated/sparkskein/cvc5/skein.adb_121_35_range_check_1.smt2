;; produced by cvc5.drv ;;
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort us_private 0)

(declare-const us_null_ext__ us_private)

;; "pow2"
(declare-fun pow2 (Int) Int)

(declare-const two_power_size_minus_one Int)

;; "two_power_size_minus_one_val"
(assert (= two_power_size_minus_one (pow2 (- 64 1))))

;; "uint_in_range"
(define-fun uint_in_range ((i Int)) Bool
  (and (<= 0 i) (<= i 18446744073709551615)))

;; "min"
(define-fun min ((x Int) (y Int)) Int
  (ite (<= x y) x y))

;; "max"
(define-fun max ((x Int) (y Int)) Int
  (ite (<= x y) y x))

;; "Min_r"
(assert (forall ((x Int) (y Int)) (=> (<= y x) (= (min x y) y))))

;; "Max_l"
(assert (forall ((x Int) (y Int)) (=> (<= y x) (= (max x y) x))))

;; "Min_comm"
(assert (forall ((x Int) (y Int)) (= (min x y) (min y x))))

;; "Max_comm"
(assert (forall ((x Int) (y Int)) (= (max x y) (max y x))))

;; "Min_assoc"
(assert
  (forall ((x Int) (y Int) (z Int)) (= (min (min x y) z) (min x (min y z)))))

;; "Max_assoc"
(assert
  (forall ((x Int) (y Int) (z Int)) (= (max (max x y) z) (max x (max y z)))))

(declare-sort unsigned_64 0)

(declare-const attr__ATTRIBUTE_MODULUS (_ BitVec 64))

;; "to_rep"
(declare-fun to_rep (unsigned_64) (_ BitVec 64))

;; "of_rep"
(declare-fun of_rep ((_ BitVec 64)) unsigned_64)

;; "inversion_axiom"
(assert
  (forall ((x unsigned_64))
    (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; "range_axiom"
(assert true)

;; "coerce_axiom"
(assert
  (forall ((x (_ BitVec 64)))
    (! (= (to_rep (of_rep x)) x) :pattern ((to_rep (of_rep x))) )))

(declare-sort u64 0)

(declare-const attr__ATTRIBUTE_MODULUS1 (_ BitVec 64))

(declare-const attr__ATTRIBUTE_MODULUS2 (_ BitVec 64))

;; "in_range"
(define-fun in_range ((x (_ BitVec 64))) Bool
  (and (bvule #x0000000000000000 x) (bvule x #x1FFFFFFFFFFFFFFF)))

;; "to_rep"
(declare-fun to_rep1 (u64) (_ BitVec 64))

;; "of_rep"
(declare-fun of_rep1 ((_ BitVec 64)) u64)

;; "inversion_axiom"
(assert
  (forall ((x u64)) (! (= (of_rep1 (to_rep1 x)) x) :pattern ((to_rep1 x)) )))

;; "range_axiom"
(assert true)

;; "coerce_axiom"
(assert
  (forall ((x (_ BitVec 64)))
    (! (= (to_rep1 (of_rep1 x)) x) :pattern ((to_rep1 (of_rep1 x))) )))

(declare-datatypes ((t 0))
  (((tqtmk (rec__first unsigned_64)(rec__last unsigned_64)))))

;; "dynamic_property"
(define-fun dynamic_property ((range_first (_ BitVec 64)) (range_last (_ BitVec 64)) (low (_ BitVec 64)) (high (_ BitVec 64))) Bool
  (=> (bvule low high) (and (in_range low) (in_range high))))

(declare-datatypes ((us_t 0))
  (((us_tqtmk (elts (Array (_ BitVec 64) u64))(rt t)))))

;; "first"
(define-fun first ((a us_t)) (_ BitVec 64)
  (to_rep (rec__first (rt a))))

;; "last"
(define-fun last ((a us_t)) (_ BitVec 64)
  (to_rep (rec__last (rt a))))

;; "length"
(define-fun length ((a us_t)) Int
  (ite (bvule (first a) (last a))
    (+ (- (bv2nat (last a)) (bv2nat (first a))) 1)
    0))

(declare-const value__size Int)

(declare-const object__size Int)

(declare-const component__size Int)

(declare-const alignment Int)

;; "value__size_axiom"
(assert (<= 0 value__size))

;; "object__size_axiom"
(assert (<= 0 object__size))

;; "component__size_axiom"
(assert (<= 0 component__size))

;; "alignment_axiom"
(assert (<= 0 alignment))

(declare-const s us_t)

(declare-const count (_ BitVec 64))

;; "dynamic_invariant"
(define-fun dynamic_invariant ((temp___expr_434 us_t) (temp___is_init_430 Bool) (temp___skip_constant_431 Bool) (temp___do_toplevel_432 Bool) (temp___do_typ_inv_433 Bool)) Bool
  (=>
    (not (= temp___skip_constant_431 true))
    (dynamic_property
      #x0000000000000000
      #x1FFFFFFFFFFFFFFF
      (first temp___expr_434)
      (last temp___expr_434))))

;; Goal "def'vc"
;; File "skein.adb", line 117, characters 0-0
(assert
  (not
  (=> (dynamic_invariant s true false true true) (uint_in_range (length s)))))

(check-sat)
(get-info :reason-unknown)
