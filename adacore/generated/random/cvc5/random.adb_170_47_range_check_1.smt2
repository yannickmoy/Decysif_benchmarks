;; produced by cvc5.drv ;;
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort us_private 0)

(declare-const us_null_ext__ us_private)

;; "pow2"
(declare-fun pow2 (Int) Int)

(declare-const two_power_size_minus_one Int)

;; "two_power_size_minus_one_val"
(assert (= two_power_size_minus_one (pow2 (- 32 1))))

;; "uint_in_range"
(define-fun uint_in_range ((i Int)) Bool
  (and (<= 0 i) (<= i 4294967295)))

;; "min"
(define-fun min ((x Int) (y Int)) Int
  (ite (<= x y) x y))

;; "max"
(define-fun max ((x Int) (y Int)) Int
  (ite (<= x y) y x))

;; "Min_r"
(assert (forall ((x Int) (y Int)) (=> (<= y x) (= (min x y) y))))

;; "Max_l"
(assert (forall ((x Int) (y Int)) (=> (<= y x) (= (max x y) x))))

;; "Min_comm"
(assert (forall ((x Int) (y Int)) (= (min x y) (min y x))))

;; "Max_comm"
(assert (forall ((x Int) (y Int)) (= (max x y) (max y x))))

;; "Min_assoc"
(assert
  (forall ((x Int) (y Int) (z Int)) (= (min (min x y) z) (min x (min y z)))))

;; "Max_assoc"
(assert
  (forall ((x Int) (y Int) (z Int)) (= (max (max x y) z) (max x (max y z)))))

;; "in_range"
(define-fun in_range ((x Int)) Bool
  (and (<= (- 2147483648) x) (<= x 2147483647)))

(declare-sort state_range 0)

;; "state_range'int"
(declare-fun state_rangeqtint (state_range) Int)

;; "state_range'axiom"
(assert
  (forall ((i state_range))
    (and (<= 0 (state_rangeqtint i)) (<= (state_rangeqtint i) 623))))

;; "in_range"
(define-fun in_range1 ((x Int)) Bool
  (and (<= 0 x) (<= x 623)))

;; "to_rep"
(define-fun to_rep ((x state_range)) Int
  (state_rangeqtint x))

;; "of_rep"
(declare-fun of_rep (Int) state_range)

;; "inversion_axiom"
(assert
  (forall ((x state_range))
    (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; "range_axiom"
(assert
  (forall ((x state_range))
    (! (in_range1 (to_rep x)) :pattern ((to_rep x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range1 x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                                (of_rep x))) )))

(declare-sort unsigned_32 0)

(declare-const attr__ATTRIBUTE_MODULUS (_ BitVec 32))

;; "to_rep"
(declare-fun to_rep1 (unsigned_32) (_ BitVec 32))

;; "of_rep"
(declare-fun of_rep1 ((_ BitVec 32)) unsigned_32)

;; "inversion_axiom"
(assert
  (forall ((x unsigned_32))
    (! (= (of_rep1 (to_rep1 x)) x) :pattern ((to_rep1 x)) )))

;; "range_axiom"
(assert true)

;; "coerce_axiom"
(assert
  (forall ((x (_ BitVec 32)))
    (! (= (to_rep1 (of_rep1 x)) x) :pattern ((to_rep1 (of_rep1 x))) )))

(declare-const value__size Int)

(declare-const object__size Int)

(declare-const component__size Int)

(declare-const alignment Int)

;; "value__size_axiom"
(assert (<= 0 value__size))

;; "object__size_axiom"
(assert (<= 0 object__size))

;; "component__size_axiom"
(assert (<= 0 component__size))

;; "alignment_axiom"
(assert (<= 0 alignment))

(declare-datatypes ((us_split_fields 0))
  (((us_split_fieldsqtmk
    (rec__random__generator__state (Array Int unsigned_32))(rec__random__generator__index state_range)))))

(declare-datatypes ((us_rep 0))
  (((us_repqtmk (us_split_fields1 us_split_fields)))))

(declare-const value__size1 Int)

(declare-const object__size1 Int)

(declare-const alignment1 Int)

;; "value__size_axiom"
(assert (<= 0 value__size1))

;; "object__size_axiom"
(assert (<= 0 object__size1))

;; "alignment_axiom"
(assert (<= 0 alignment1))

(declare-const random__generator__state__first__bit Int)

(declare-const random__generator__state__last__bit Int)

(declare-const random__generator__state__position Int)

;; "random__generator__state__first__bit_axiom"
(assert (<= 0 random__generator__state__first__bit))

;; "random__generator__state__last__bit_axiom"
(assert
  (< random__generator__state__first__bit random__generator__state__last__bit))

;; "random__generator__state__position_axiom"
(assert (<= 0 random__generator__state__position))

(declare-const random__generator__index__first__bit Int)

(declare-const random__generator__index__last__bit Int)

(declare-const random__generator__index__position Int)

;; "random__generator__index__first__bit_axiom"
(assert (<= 0 random__generator__index__first__bit))

;; "random__generator__index__last__bit_axiom"
(assert
  (< random__generator__index__first__bit random__generator__index__last__bit))

;; "random__generator__index__position_axiom"
(assert (<= 0 random__generator__index__position))

(declare-const dummy us_rep)

;; "dynamic_invariant"
(define-fun dynamic_invariant ((temp___expr_210 us_rep) (temp___is_init_206 Bool) (temp___skip_constant_207 Bool) (temp___do_toplevel_208 Bool) (temp___do_typ_inv_209 Bool)) Bool
  true)

(declare-const min1 Int)

(declare-const max1 Int)

(declare-const n (_ BitVec 32))

(declare-const slop (_ BitVec 32))

;; Goal "def'vc"
;; File "random.ads", line 51, characters 0-0
(assert
  (not
  (forall ((g__split_fields us_split_fields) (value Int))
    (=>
      (dynamic_invariant (us_repqtmk g__split_fields) true false true true)
      (=>
        (in_range value)
        (=>
          (in_range min1)
          (=>
            (in_range max1)
            (=>
              (<= min1 max1)
              (forall ((x (_ BitVec 32)))
                (=>
                  (exists ((spark__branch Bool))
                    (and
                      (= spark__branch (and (ite (= min1 (- 2147483648))
                                              true
                                              false) (ite (= max1 2147483647)
                                                       true
                                                       false)))
                      (ite (= spark__branch true)
                        (exists ((g__split_fields1 us_split_fields))
                          (dynamic_invariant
                            (us_repqtmk g__split_fields1)
                            true
                            true
                            true
                            true))
                        (let ((o (+ (- max1 min1) 1)))
                          (and
                            (uint_in_range o)
                            (and
                              (= ((_ int2bv 32) o) n)
                              (and
                                (= (bvadd (bvurem #xFFFFFFFF n) #x00000001) 
                                slop)
                                (exists ((x1 (_ BitVec 32)))
                                  (and
                                    (exists ((g__split_fields1 us_split_fields))
                                      (and
                                        (dynamic_invariant
                                          (us_repqtmk g__split_fields1)
                                          true
                                          true
                                          true
                                          true)
                                        (exists ((g__split_fields2 us_split_fields))
                                          (and
                                            (dynamic_invariant
                                              (us_repqtmk g__split_fields2)
                                              true
                                              true
                                              true
                                              true)
                                            (exists ((o1 Bool))
                                              (and
                                                (ite (= slop n)
                                                  (= o1 true)
                                                  (= o1 (ite (bvule x1 (bvsub #xFFFFFFFF 
                                                          slop))
                                                          true
                                                          false)))
                                                (= o1 true)))))))
                                    (and
                                      (= x (bvurem x1 n))
                                      (and
                                        (bvule #x00000000 x)
                                        (bvule x (bvsub n #x00000001)))))))))))))
                  (<= (- 2147483648) (+ min1 (bv2nat x)))))))))))))

(check-sat)
(get-info :reason-unknown)
