(* this is a prelude for Alt-Ergo integer arithmetic *)
logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool_True :
  (forall z:'a. forall z1:'a. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

function andb(x: bool, y: bool) : bool = match_bool(x, y, false)

type us_private

logic us_null_ext__ : us_private

function of_int(i: int) : bool = (if (i = 0) then false else true)

type integer

logic integerqtint : integer -> int

axiom integerqtaxiom :
  (forall i:integer. (((- 2147483648) <= integerqtint(i)) and
  (integerqtint(i) <= 2147483647)))

predicate in_range(x: int) = (((- 2147483648) <= x) and (x <= 2147483647))

type us_rep

logic value__size : int

logic object__size : int

logic alignment : int

axiom value__size_axiom : (0 <= value__size)

axiom object__size_axiom : (0 <= object__size)

axiom alignment_axiom : (0 <= alignment)

logic dummy : us_rep

logic oeq : us_rep, us_rep -> bool

logic has_key : us_rep, int -> bool

logic get : us_rep, int -> int

logic value__size1 : int

logic object__size1 : int

logic alignment1 : int

axiom value__size_axiom1 : (0 <= value__size1)

axiom object__size_axiom1 : (0 <= object__size1)

axiom alignment_axiom1 : (0 <= alignment1)

logic dummy1 : us_rep

logic is_add : us_rep, int, us_rep -> bool

logic ole : us_rep, us_rep -> bool

logic keys_included : us_rep, us_rep -> bool

function same_keys(param__left: us_rep, param__right: us_rep) : bool =
  andb(keys_included(param__left, param__right), keys_included(param__right,
  param__left))

logic keys_included_except : us_rep, us_rep, int -> bool

logic elements_equal_except : us_rep, us_rep, int -> bool

logic occ1 : us_rep

logic occ2 : us_rep

logic res1 : us_rep

logic res2 : us_rep

logic k : int

type positive

logic positiveqtint : positive -> int

axiom positiveqtaxiom :
  (forall i:positive. ((1 <= positiveqtint(i)) and
  (positiveqtint(i) <= 2147483647)))

predicate in_range1(x: int) = ((1 <= x) and (x <= 2147483647))

axiom has_key__post_axiom : true

axiom lemma_has_key_equivalent__post_axiom :
  (forall param__container:us_rep.
  (forall param__key:int. ((in_range(param__key) and ((of_int(1) = true) and
  (not (has_key(param__container, param__key) = true)))) ->
  (forall k1:int. ((in_range(k1) and (has_key(param__container,
  k1) = true)) -> (not (param__key = k1)))))))

axiom get__post_axiom :
  (forall param__container:us_rep.
  (forall param__key:int [get(param__container, param__key)].
  ((in_range(param__key) and (has_key(param__container,
  param__key) = true)) -> in_range1(get(param__container, param__key)))))

axiom lemma_get_equivalent__post_axiom :
  (forall param__container:us_rep.
  (forall param__key_1:int. forall param__key_2:int.
  (((in_range(param__key_1) and in_range(param__key_2)) and
  (((of_int(1) = true) and (param__key_1 = param__key_2)) and
  ((has_key(param__container, param__key_1) = true) or
  (has_key(param__container, param__key_2) = true)))) ->
  (get(param__container, param__key_1) = get(param__container,
  param__key_2)))))

axiom ole__post_axiom :
  (forall param__left:us_rep. forall param__right:us_rep [ole(param__left,
  param__right)]. ((ole(param__left, param__right) = true) <->
  (forall key:int. ((in_range(key) and (has_key(param__left, key) = true)) ->
  ((has_key(param__right, key) = true) and (get(param__right,
  key) = get(param__left, key)))))))

axiom oeq__post_axiom :
  (forall param__left:us_rep. forall param__right:us_rep [oeq(param__left,
  param__right)]. ((oeq(param__left, param__right) = true) <->
  ((forall key:int. ((in_range(key) and (has_key(param__left,
   key) = true)) -> ((has_key(param__right, key) = true) and
   (get(param__right, key) = get(param__left, key))))) and
  (forall key:int. ((in_range(key) and (has_key(param__right,
  key) = true)) -> (has_key(param__left, key) = true))))))

axiom keys_included__post_axiom :
  (forall param__left:us_rep. forall param__right:us_rep
  [keys_included(param__left, param__right)]. ((keys_included(param__left,
  param__right) = true) <->
  (forall key:int. ((in_range(key) and (has_key(param__left, key) = true)) ->
  (has_key(param__right, key) = true)))))

axiom keys_included_except__post_axiom :
  (forall param__left:us_rep. forall param__right:us_rep.
  (forall param__new_key:int [keys_included_except(param__left, param__right,
  param__new_key)]. (in_range(param__new_key) ->
  ((keys_included_except(param__left, param__right,
  param__new_key) = true) <->
  (forall key:int. ((in_range(key) and (has_key(param__left, key) = true)) ->
  ((not (key = param__new_key)) -> (has_key(param__right, key) = true))))))))

axiom elements_equal_except__post_axiom :
  (forall param__left:us_rep. forall param__right:us_rep.
  (forall param__new_key:int [elements_equal_except(param__left,
  param__right, param__new_key)]. (in_range(param__new_key) ->
  ((elements_equal_except(param__left, param__right,
  param__new_key) = true) <->
  (forall key:int. ((in_range(key) and (has_key(param__left, key) = true)) ->
  ((not (key = param__new_key)) -> ((has_key(param__right, key) = true) and
  (get(param__left, key) = get(param__right, key))))))))))

axiom is_add__post_axiom : true

axiom is_add__def_axiom :
  (forall param__occ:us_rep. forall param__res:us_rep.
  (forall param__k:int [is_add(param__occ, param__k, param__res)].
  ((is_add(param__occ, param__k, param__res) = true) <->
  (if (has_key(param__occ, param__k) = true) then (((same_keys(param__res,
  param__occ) = true) and ((get(param__res, param__k) - 1) = get(param__occ,
  param__k))) and (elements_equal_except(param__res, param__occ,
  param__k) = true)) else ((((has_key(param__res, param__k) = true) and
  (get(param__res, param__k) = 1)) and (ole(param__occ,
  param__res) = true)) and (keys_included_except(param__res, param__occ,
  param__k) = true))))))

 (* "recursive_mergesort.ads", line 62, characters 0-0 *)
goal defqtvc : (in_range(k) -> ((((oeq(occ1, occ2) = true) and (is_add(occ1,
  k, res1) = true)) and (is_add(occ2, k, res2) = true)) -> (oeq(res1,
  res2) = true)))
