;; produced by cvc5.drv ;;
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort us_private 0)

(declare-const us_null_ext__ us_private)

;; "pow2"
(declare-fun pow2 (Int) Int)

(declare-const two_power_size_minus_one Int)

;; "two_power_size_minus_one_val"
(assert (= two_power_size_minus_one (pow2 (- 32 1))))

;; "min"
(define-fun min ((x Int) (y Int)) Int
  (ite (<= x y) x y))

;; "max"
(define-fun max ((x Int) (y Int)) Int
  (ite (<= x y) y x))

;; "Min_r"
(assert (forall ((x Int) (y Int)) (=> (<= y x) (= (min x y) y))))

;; "Max_l"
(assert (forall ((x Int) (y Int)) (=> (<= y x) (= (max x y) x))))

;; "Min_comm"
(assert (forall ((x Int) (y Int)) (= (min x y) (min y x))))

;; "Max_comm"
(assert (forall ((x Int) (y Int)) (= (max x y) (max y x))))

;; "Min_assoc"
(assert
  (forall ((x Int) (y Int) (z Int)) (= (min (min x y) z) (min x (min y z)))))

;; "Max_assoc"
(assert
  (forall ((x Int) (y Int) (z Int)) (= (max (max x y) z) (max x (max y z)))))

(declare-sort character 0)

;; "in_range"
(define-fun in_range ((x Int)) Bool
  (and (<= 0 x) (<= x 255)))

;; "to_rep"
(declare-fun to_rep (character) Int)

;; "of_rep"
(declare-fun of_rep (Int) character)

;; "inversion_axiom"
(assert
  (forall ((x character))
    (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; "range_axiom"
(assert
  (forall ((x character)) (! (in_range (to_rep x)) :pattern ((to_rep x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                               (of_rep x))) )))

;; "bool_eq"
(define-fun bool_eq ((a (Array Int character)) (a__first Int) (a__last Int) (b (Array Int character)) (b__first Int) (b__last Int)) Bool
  (ite (and
         (ite (<= a__first a__last)
           (and
             (<= b__first b__last)
             (= (- a__last a__first) (- b__last b__first)))
           (< b__last b__first))
         (forall ((temp___idx_105 Int))
           (=>
             (and (<= a__first temp___idx_105) (<= temp___idx_105 a__last))
             (= (to_rep (select a temp___idx_105)) (to_rep
                                                     (select b (+ (- b__first a__first) temp___idx_105)))))))
    true
    false))

;; "bool_eq_rev"
(assert
  (forall ((a (Array Int character)) (b (Array Int character)))
    (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
      (=>
        (= (bool_eq b b__first b__last a a__first a__last) true)
        (and
          (ite (<= a__first a__last)
            (and
              (<= b__first b__last)
              (= (- a__last a__first) (- b__last b__first)))
            (< b__last b__first))
          (forall ((temp___idx_105 Int))
            (=>
              (and (<= a__first temp___idx_105) (<= temp___idx_105 a__last))
              (= (to_rep (select a temp___idx_105)) (to_rep
                                                      (select b (+ (- b__first a__first) temp___idx_105)))))))))))

(declare-sort integer 0)

;; "integer'int"
(declare-fun integerqtint (integer) Int)

;; "integer'axiom"
(assert
  (forall ((i integer))
    (and
      (<= (- 2147483648) (integerqtint i))
      (<= (integerqtint i) 2147483647))))

;; "in_range"
(define-fun in_range1 ((x Int)) Bool
  (and (<= (- 2147483648) x) (<= x 2147483647)))

(declare-sort positive 0)

;; "positive'int"
(declare-fun positiveqtint (positive) Int)

;; "positive'axiom"
(assert
  (forall ((i positive))
    (and (<= 1 (positiveqtint i)) (<= (positiveqtint i) 2147483647))))

;; "in_range"
(define-fun in_range2 ((x Int)) Bool
  (and (<= 1 x) (<= x 2147483647)))

;; "to_rep"
(define-fun to_rep1 ((x integer)) Int
  (integerqtint x))

;; "of_rep"
(declare-fun of_rep1 (Int) integer)

;; "inversion_axiom"
(assert
  (forall ((x integer))
    (! (= (of_rep1 (to_rep1 x)) x) :pattern ((to_rep1 x)) )))

;; "range_axiom"
(assert
  (forall ((x integer)) (! (in_range1 (to_rep1 x)) :pattern ((to_rep1 x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range1 x) (= (to_rep1 (of_rep1 x)) x)) :pattern ((to_rep1
                                                                  (of_rep1 x))) )))

(declare-datatypes ((t 0))
  (((tqtmk (rec__first integer)(rec__last integer)))))

;; "dynamic_property"
(define-fun dynamic_property ((range_first Int) (range_last Int) (low Int) (high Int)) Bool
  (and
    (in_range1 low)
    (and
      (in_range1 high)
      (=> (<= low high) (and (in_range2 low) (in_range2 high))))))

(declare-datatypes ((us_t 0))
  (((us_tqtmk (elts (Array Int character))(rt t)))))

;; "to_array"
(define-fun to_array ((a us_t)) (Array Int character)
  (elts a))

;; "first"
(define-fun first ((a us_t)) Int
  (to_rep1 (rec__first (rt a))))

;; "last"
(define-fun last ((a us_t)) Int
  (to_rep1 (rec__last (rt a))))

;; "length"
(define-fun length ((a us_t)) Int
  (ite (<= (first a) (last a)) (+ (- (last a) (first a)) 1) 0))

(declare-const value__size Int)

(declare-const object__size Int)

(declare-const component__size Int)

(declare-const alignment Int)

;; "value__size_axiom"
(assert (<= 0 value__size))

;; "object__size_axiom"
(assert (<= 0 object__size))

;; "component__size_axiom"
(assert (<= 0 component__size))

;; "alignment_axiom"
(assert (<= 0 alignment))

;; "dynamic_invariant"
(define-fun dynamic_invariant ((temp___expr_110 us_t) (temp___is_init_106 Bool) (temp___skip_constant_107 Bool) (temp___do_toplevel_108 Bool) (temp___do_typ_inv_109 Bool)) Bool
  (=>
    (not (= temp___skip_constant_107 true))
    (dynamic_property
      1
      2147483647
      (first temp___expr_110)
      (last temp___expr_110))))

(declare-sort us_rep 0)

(declare-const value__size1 Int)

(declare-const object__size1 Int)

(declare-const alignment1 Int)

;; "value__size_axiom"
(assert (<= 0 value__size1))

;; "object__size_axiom"
(assert (<= 0 object__size1))

;; "alignment_axiom"
(assert (<= 0 alignment1))

(declare-const dummy us_rep)

(declare-datatypes ((vector__ref 0))
  (((vector__refqtmk (vector__content us_rep)))))

;; "last_index"
(declare-fun last_index (us_rep) Int)

;; "in_range"
(define-fun in_range3 ((x Int)) Bool
  (and (<= 0 x) (<= x 2147483647)))

(declare-sort us_rep1 0)

(declare-const value__size2 Int)

(declare-const object__size2 Int)

(declare-const alignment2 Int)

;; "value__size_axiom"
(assert (<= 0 value__size2))

;; "object__size_axiom"
(assert (<= 0 object__size2))

;; "alignment_axiom"
(assert (<= 0 alignment2))

(declare-const dummy1 us_rep1)

;; "to_rep"
(define-fun to_rep2 ((x positive)) Int
  (positiveqtint x))

;; "of_rep"
(declare-fun of_rep2 (Int) positive)

;; "inversion_axiom"
(assert
  (forall ((x positive))
    (! (= (of_rep2 (to_rep2 x)) x) :pattern ((to_rep2 x)) )))

;; "range_axiom"
(assert
  (forall ((x positive)) (! (in_range2 (to_rep2 x)) :pattern ((to_rep2 x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range2 x) (= (to_rep2 (of_rep2 x)) x)) :pattern ((to_rep2
                                                                  (of_rep2 x))) )))

(declare-sort name_id 0)

;; "name_id'int"
(declare-fun name_idqtint (name_id) Int)

;; "name_id'axiom"
(assert
  (forall ((i name_id))
    (and (<= 0 (name_idqtint i)) (<= (name_idqtint i) 2147483647))))

;; "in_range"
(define-fun in_range4 ((x Int)) Bool
  (and (<= 0 x) (<= x 2147483647)))

;; "to_rep"
(define-fun to_rep3 ((x name_id)) Int
  (name_idqtint x))

;; "of_rep"
(declare-fun of_rep3 (Int) name_id)

;; "inversion_axiom"
(assert
  (forall ((x name_id))
    (! (= (of_rep3 (to_rep3 x)) x) :pattern ((to_rep3 x)) )))

;; "range_axiom"
(assert
  (forall ((x name_id)) (! (in_range4 (to_rep3 x)) :pattern ((to_rep3 x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range4 x) (= (to_rep3 (of_rep3 x)) x)) :pattern ((to_rep3
                                                                  (of_rep3 x))) )))

(declare-sort char_table_index 0)

;; "char_table_index'int"
(declare-fun char_table_indexqtint (char_table_index) Int)

;; "char_table_index'axiom"
(assert
  (forall ((i char_table_index))
    (and
      (<= 0 (char_table_indexqtint i))
      (<= (char_table_indexqtint i) 2147483646))))

;; "in_range"
(define-fun in_range5 ((x Int)) Bool
  (and (<= 0 x) (<= x 2147483646)))

;; "to_rep"
(define-fun to_rep4 ((x char_table_index)) Int
  (char_table_indexqtint x))

;; "of_rep"
(declare-fun of_rep4 (Int) char_table_index)

;; "inversion_axiom"
(assert
  (forall ((x char_table_index))
    (! (= (of_rep4 (to_rep4 x)) x) :pattern ((to_rep4 x)) )))

;; "range_axiom"
(assert
  (forall ((x char_table_index))
    (! (in_range5 (to_rep4 x)) :pattern ((to_rep4 x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range5 x) (= (to_rep4 (of_rep4 x)) x)) :pattern ((to_rep4
                                                                  (of_rep4 x))) )))

(declare-datatypes ((us_split_fields 0))
  (((us_split_fieldsqtmk
    (rec__ada___names__data__name_entry__table_index char_table_index)(rec__ada___names__data__name_entry__length positive)(rec__ada___names__data__name_entry__next_hash name_id)))))

(declare-datatypes ((us_rep2 0))
  (((us_repqtmk (us_split_fields1 us_split_fields)))))

;; "bool_eq"
(define-fun bool_eq1 ((a us_rep2) (b us_rep2)) Bool
  (ite (and
         (= (to_rep4
              (rec__ada___names__data__name_entry__table_index
                (us_split_fields1 a))) (to_rep4
                                         (rec__ada___names__data__name_entry__table_index
                                           (us_split_fields1 b))))
         (and
           (= (to_rep2
                (rec__ada___names__data__name_entry__length
                  (us_split_fields1 a))) (to_rep2
                                           (rec__ada___names__data__name_entry__length
                                             (us_split_fields1 b))))
           (= (to_rep3
                (rec__ada___names__data__name_entry__next_hash
                  (us_split_fields1 a))) (to_rep3
                                           (rec__ada___names__data__name_entry__next_hash
                                             (us_split_fields1 b))))))
    true
    false))

(declare-const value__size3 Int)

(declare-const object__size3 Int)

(declare-const alignment3 Int)

;; "value__size_axiom"
(assert (<= 0 value__size3))

;; "object__size_axiom"
(assert (<= 0 object__size3))

;; "alignment_axiom"
(assert (<= 0 alignment3))

(declare-const ada___names__data__name_entry__table_index__first__bit Int)

(declare-const ada___names__data__name_entry__table_index__last__bit Int)

(declare-const ada___names__data__name_entry__table_index__position Int)

;; "ada___names__data__name_entry__table_index__first__bit_axiom"
(assert (<= 0 ada___names__data__name_entry__table_index__first__bit))

;; "ada___names__data__name_entry__table_index__last__bit_axiom"
(assert
  (< ada___names__data__name_entry__table_index__first__bit ada___names__data__name_entry__table_index__last__bit))

;; "ada___names__data__name_entry__table_index__position_axiom"
(assert (<= 0 ada___names__data__name_entry__table_index__position))

(declare-const ada___names__data__name_entry__length__first__bit Int)

(declare-const ada___names__data__name_entry__length__last__bit Int)

(declare-const ada___names__data__name_entry__length__position Int)

;; "ada___names__data__name_entry__length__first__bit_axiom"
(assert (<= 0 ada___names__data__name_entry__length__first__bit))

;; "ada___names__data__name_entry__length__last__bit_axiom"
(assert
  (< ada___names__data__name_entry__length__first__bit ada___names__data__name_entry__length__last__bit))

;; "ada___names__data__name_entry__length__position_axiom"
(assert (<= 0 ada___names__data__name_entry__length__position))

(declare-const ada___names__data__name_entry__next_hash__first__bit Int)

(declare-const ada___names__data__name_entry__next_hash__last__bit Int)

(declare-const ada___names__data__name_entry__next_hash__position Int)

;; "ada___names__data__name_entry__next_hash__first__bit_axiom"
(assert (<= 0 ada___names__data__name_entry__next_hash__first__bit))

;; "ada___names__data__name_entry__next_hash__last__bit_axiom"
(assert
  (< ada___names__data__name_entry__next_hash__first__bit ada___names__data__name_entry__next_hash__last__bit))

;; "ada___names__data__name_entry__next_hash__position_axiom"
(assert (<= 0 ada___names__data__name_entry__next_hash__position))

(declare-const dummy2 us_rep2)

(declare-sort us_rep3 0)

(declare-const value__size4 Int)

(declare-const object__size4 Int)

(declare-const alignment4 Int)

;; "value__size_axiom"
(assert (<= 0 value__size4))

;; "object__size_axiom"
(assert (<= 0 object__size4))

;; "alignment_axiom"
(assert (<= 0 alignment4))

(declare-const dummy3 us_rep3)

;; "get"
(declare-fun get (us_rep3
  Int) us_rep2)

;; "model"
(declare-fun model1 (us_rep) us_rep3)

;; "element"
(define-fun element ((param__container us_rep) (param__index Int)) us_rep2
  (get (model1 param__container) param__index))

;; "invariant__"
(declare-fun invariant__ ((Array (_ BitVec 32) name_id)
  us_rep1
  us_rep) Bool)

;; "valid_tables"
(declare-fun valid_tables (us_rep1
  us_rep) Bool)

;; "valid_name_table"
(declare-fun valid_name_table (us_rep1
  us_rep) Bool)

;; "valid_hashes"
(declare-fun valid_hashes ((Array (_ BitVec 32) name_id)
  us_rep) Bool)

(declare-const s us_t)

;; "to_string"
(declare-fun to_string (Int
  (Array (_ BitVec 32) name_id)
  us_rep1
  us_rep) us_t)

;; "to_string__function_guard"
(declare-fun to_string__function_guard (us_t
  Int
  (Array (_ BitVec 32) name_id)
  us_rep1
  us_rep) Bool)

(declare-sort us_rep4 0)

(declare-const value__size5 Int)

(declare-const object__size5 Int)

(declare-const alignment5 Int)

;; "value__size_axiom"
(assert (<= 0 value__size5))

;; "object__size_axiom"
(assert (<= 0 object__size5))

;; "alignment_axiom"
(assert (<= 0 alignment5))

(declare-const dummy4 us_rep4)

;; "model"
(declare-fun model2 (us_rep1) us_rep4)

(declare-const value__size6 Int)

(declare-const object__size6 Int)

(declare-const alignment6 Int)

;; "value__size_axiom"
(assert (<= 0 value__size6))

;; "object__size_axiom"
(assert (<= 0 object__size6))

;; "alignment_axiom"
(assert (<= 0 alignment6))

(declare-const dummy5 Int)

;; "last"
(declare-fun last1 (us_rep4) Int)

;; "length"
(define-fun length1 ((param__container us_rep4)) Int
  (- (+ (last1 param__container) 1) 0))

;; "length"
(define-fun length2 ((param__container us_rep1)) Int
  (length1 (model2 param__container)))

;; "last"
(declare-fun last2 (us_rep3) Int)

;; "length"
(define-fun length3 ((param__container us_rep3)) Int
  (- (+ (last2 param__container) 1) 1))

;; "length"
(define-fun length4 ((param__container us_rep)) Int
  (length3 (model1 param__container)))

(declare-const attr__ATTRIBUTE_MODULUS (_ BitVec 32))

;; "hash"
(declare-fun hash (us_t) (_ BitVec 32))

(declare-const h (_ BitVec 32))

;; "equal_except"
(define-fun equal_except ((param__left us_rep3) (param__right us_rep3) (param__position Int)) Bool
  (and (= (length3 param__left) (length3 param__right)) (ite (forall 
                                                               ((i Int))
                                                               (=>
                                                                 (and
                                                                   (<= 1 i)
                                                                   (<= i 
                                                                   (last2
                                                                    param__left)))
                                                                 (=>
                                                                   (not
                                                                    (= i param__position))
                                                                   (= 
                                                                   (get
                                                                    param__left
                                                                    i) 
                                                                   (get
                                                                    param__right
                                                                    i)))))
                                                          true
                                                          false)))

;; "in_range"
(define-fun in_range6 ((x Int)) Bool
  (and (<= 1 x) (<= x 2147483647)))

(declare-const attr__ATTRIBUTE_MODULUS1 (_ BitVec 32))

;; "in_range"
(define-fun in_range7 ((x (_ BitVec 32))) Bool
  (and (bvule #x00000000 x) (bvule x #x000000FF)))

(declare-const value__size7 Int)

(declare-const object__size7 Int)

(declare-const component__size1 Int)

(declare-const alignment7 Int)

;; "value__size_axiom"
(assert (<= 0 value__size7))

;; "object__size_axiom"
(assert (<= 0 object__size7))

;; "component__size_axiom"
(assert (<= 0 component__size1))

;; "alignment_axiom"
(assert (<= 0 alignment7))

;; "last_index"
(declare-fun last_index1 (us_rep1) Int)

;; "valid_entry"
(declare-fun valid_entry (us_rep2
  us_rep1
  us_rep) Bool)

;; "in_range"
(define-fun in_range8 ((x Int)) Bool
  (and (<= (- 1) x) (<= x 2147483646)))

;; "in_range"
(define-fun in_range9 ((x Int)) Bool
  (and (<= 0 x) (<= x 2147483647)))

;; "in_range"
(define-fun in_range10 ((x Int)) Bool
  (and (<= (- 1) x) (<= x 2147483646)))

;; "last_index__post_axiom"
(assert
  (forall ((param__container us_rep))
    (! (in_range3 (last_index param__container)) :pattern ((last_index
                                                             param__container)) )))

;; "last_index__post_axiom"
(assert
  (forall ((param__container us_rep1))
    (! (in_range8 (last_index1 param__container)) :pattern ((last_index1
                                                              param__container)) )))

;; "valid_tables__post_axiom"
(assert true)

;; "valid_tables__def_axiom"
(assert
  (forall ((Names__char_table___char_table___ us_rep1))
    (forall ((Names__entry_table___entry_table___ us_rep))
      (! (=
           (= (valid_tables
                Names__char_table___char_table___
                Names__entry_table___entry_table___) true)
           (and
             (<= (last_index Names__entry_table___entry_table___) 2147483647)
             (<= (last_index1 Names__char_table___char_table___) 2147483646))) :pattern (
      (valid_tables
        Names__char_table___char_table___
        Names__entry_table___entry_table___)) ))))

;; "valid_entry__post_axiom"
(assert true)

;; "valid_entry__def_axiom"
(assert
  (forall ((param__e us_rep2))
    (forall ((Names__char_table___char_table___ us_rep1))
      (forall ((Names__entry_table___entry_table___ us_rep))
        (! (=
             (= (valid_entry
                  param__e
                  Names__char_table___char_table___
                  Names__entry_table___entry_table___) true)
             (and
               (<= (to_rep3
                     (rec__ada___names__data__name_entry__next_hash
                       (us_split_fields1 param__e))) (last_index
                                                       Names__entry_table___entry_table___))
               (<= (- (to_rep2
                        (rec__ada___names__data__name_entry__length
                          (us_split_fields1 param__e))) 1) (- (last_index1
                                                                Names__char_table___char_table___) 
               (to_rep4
                 (rec__ada___names__data__name_entry__table_index
                   (us_split_fields1 param__e))))))) :pattern ((valid_entry
                                                                 param__e
                                                                 Names__char_table___char_table___
                                                                 Names__entry_table___entry_table___)) )))))

;; "last__post_axiom"
(assert
  (forall ((param__container us_rep3))
    (! (in_range9 (last2 param__container)) :pattern ((last2
                                                        param__container)) )))

;; "get__post_axiom"
(assert true)

;; "model__post_axiom"
(assert
  (forall ((param__container us_rep))
    (! (= (last2 (model1 param__container)) (last_index param__container)) :pattern (
    (model1
      param__container)) )))

;; "valid_name_table__post_axiom"
(assert true)

;; "valid_name_table__def_axiom"
(assert
  (forall ((Names__char_table___char_table___ us_rep1))
    (forall ((Names__entry_table___entry_table___ us_rep))
      (! (=
           (= (valid_name_table
                Names__char_table___char_table___
                Names__entry_table___entry_table___) true)
           (forall ((i Int))
             (=>
               (and
                 (<= 1 i)
                 (<= i (last_index Names__entry_table___entry_table___)))
               (= (valid_entry
                    (element Names__entry_table___entry_table___ i)
                    Names__char_table___char_table___
                    Names__entry_table___entry_table___) true)))) :pattern (
      (valid_name_table
        Names__char_table___char_table___
        Names__entry_table___entry_table___)) ))))

;; "valid_hashes__post_axiom"
(assert true)

;; "valid_hashes__def_axiom"
(assert
  (forall ((Names__hash_table___hash_table___ (Array (_ BitVec 32) name_id)))
    (forall ((Names__entry_table___entry_table___ us_rep))
      (! (=
           (= (valid_hashes
                Names__hash_table___hash_table___
                Names__entry_table___entry_table___) true)
           (forall ((h1 (_ BitVec 32)))
             (=>
               (and (bvule #x00000000 h1) (bvule h1 #x000000FF))
               (<= (to_rep3 (select Names__hash_table___hash_table___ h1)) 
               (last_index
                 Names__entry_table___entry_table___))))) :pattern ((valid_hashes
                                                                    Names__hash_table___hash_table___
                                                                    Names__entry_table___entry_table___)) ))))

;; "invariant____post_axiom"
(assert true)

;; "invariant____def_axiom"
(assert
  (forall ((Names__hash_table___hash_table___ (Array (_ BitVec 32) name_id)))
    (forall ((Names__char_table___char_table___ us_rep1))
      (forall ((Names__entry_table___entry_table___ us_rep))
        (! (=
             (= (invariant__
                  Names__hash_table___hash_table___
                  Names__char_table___char_table___
                  Names__entry_table___entry_table___) true)
             (and
               (and
                 (= (valid_tables
                      Names__char_table___char_table___
                      Names__entry_table___entry_table___) true)
                 (= (valid_name_table
                      Names__char_table___char_table___
                      Names__entry_table___entry_table___) true))
               (= (valid_hashes
                    Names__hash_table___hash_table___
                    Names__entry_table___entry_table___) true))) :pattern (
        (invariant__
          Names__hash_table___hash_table___
          Names__char_table___char_table___
          Names__entry_table___entry_table___)) )))))

;; "last__post_axiom"
(assert
  (forall ((param__container us_rep4))
    (! (in_range10 (last1 param__container)) :pattern ((last1
                                                         param__container)) )))

;; "model__post_axiom"
(assert
  (forall ((param__container us_rep1))
    (! (= (last1 (model2 param__container)) (last_index1 param__container)) :pattern (
    (model2
      param__container)) )))

;; "hash__post_axiom"
(assert true)

;; Goal "def'vc"
;; File "names.ads", line 44, characters 0-0
(assert
  (not
  (forall ((entry_table us_rep) (char_table us_rep1) (hash_table (Array (_ BitVec 32) name_id)) (n Int))
    (=>
      (dynamic_invariant s true false true true)
      (=>
        (in_range4 n)
        (=>
          (= (invariant__ hash_table char_table entry_table) true)
          (forall ((entry_table1 us_rep) (char_table1 us_rep1) (hash_table1 (Array (_ BitVec 32) name_id)))
            (=>
              (exists ((ptr Int))
                (and
                  (= ptr 0)
                  (and
                    (in_range4 ptr)
                    (let ((o (bvurem (hash s) #x00000100)))
                      (and
                        (in_range7 o)
                        (and
                          (= o h)
                          (and
                            (in_range7 h)
                            (exists ((spark__branch Bool))
                              (and
                                (= spark__branch (ite (= (length s) 0)
                                                   true
                                                   false))
                                (ite (= spark__branch true)
                                  (and
                                    (and
                                      (= entry_table1 entry_table)
                                      (= char_table1 char_table))
                                    (= hash_table1 hash_table))
                                  (exists ((o1 Int))
                                    (and
                                      (= (to_rep3 (select hash_table h)) o1)
                                      (exists ((n1 Int))
                                        (and
                                          (= n1 o1)
                                          (or
                                            (and
                                              (and
                                                (and
                                                  (exists ((spark__branch1 Bool))
                                                    (and
                                                      (= spark__branch1 
                                                      (ite (in_range6 n1)
                                                        true
                                                        false))
                                                      (and
                                                        (= spark__branch1 true)
                                                        (exists ((ptr1 Int))
                                                          (and
                                                            (= ptr1 n1)
                                                            (let ((temp___458 
                                                              (to_string
                                                                ptr1
                                                                hash_table
                                                                char_table
                                                                entry_table)))
                                                              (and
                                                                (and
                                                                  (to_string__function_guard
                                                                    temp___458
                                                                    ptr1
                                                                    hash_table
                                                                    char_table
                                                                    entry_table)
                                                                  (dynamic_invariant
                                                                    temp___458
                                                                    true
                                                                    false
                                                                    true
                                                                    true))
                                                                (exists 
                                                                  ((spark__branch2 Bool))
                                                                  (and
                                                                    (= spark__branch2 
                                                                    (bool_eq
                                                                    (to_array
                                                                    temp___458)
                                                                    (first
                                                                    temp___458)
                                                                    (last
                                                                    temp___458)
                                                                    (to_array
                                                                    s)
                                                                    (first s)
                                                                    (last s)))
                                                                    (=>
                                                                    (not
                                                                    (= spark__branch2 true))
                                                                    (and
                                                                    (=
                                                                    (= 
                                                                    (invariant__
                                                                    hash_table
                                                                    char_table
                                                                    entry_table) true)
                                                                    (and
                                                                    (and
                                                                    (= 
                                                                    (valid_tables
                                                                    char_table
                                                                    entry_table) true)
                                                                    (= 
                                                                    (valid_name_table
                                                                    char_table
                                                                    entry_table) true))
                                                                    (= 
                                                                    (valid_hashes
                                                                    hash_table
                                                                    entry_table) true)))
                                                                    (and
                                                                    (in_range3
                                                                    (last_index
                                                                    entry_table))
                                                                    (exists 
                                                                    ((n2 Int) (ptr2 Int))
                                                                    (and
                                                                    (and
                                                                    (and
                                                                    (in_range6
                                                                    ptr2)
                                                                    (<= ptr2 
                                                                    (last_index
                                                                    entry_table)))
                                                                    (= 
                                                                    (invariant__
                                                                    hash_table
                                                                    char_table
                                                                    entry_table) true))
                                                                    (and
                                                                    (and
                                                                    (in_range4
                                                                    ptr2)
                                                                    (= n2 n1))
                                                                    (let ((o2 
                                                                    (element
                                                                    entry_table
                                                                    ptr2)))
                                                                    (and
                                                                    (= 
                                                                    (bool_eq1
                                                                    o2
                                                                    (get
                                                                    (model1
                                                                    entry_table)
                                                                    ptr2)) true)
                                                                    (exists 
                                                                    ((o3 Int))
                                                                    (and
                                                                    (= 
                                                                    (to_rep3
                                                                    (rec__ada___names__data__name_entry__next_hash
                                                                    (us_split_fields1
                                                                    o2))) o3)
                                                                    (and
                                                                    (not
                                                                    (= o3 0))
                                                                    (let ((o4 
                                                                    (element
                                                                    entry_table
                                                                    ptr2)))
                                                                    (and
                                                                    (= 
                                                                    (bool_eq1
                                                                    o4
                                                                    (get
                                                                    (model1
                                                                    entry_table)
                                                                    ptr2)) true)
                                                                    (exists 
                                                                    ((o5 Int))
                                                                    (and
                                                                    (= 
                                                                    (to_rep3
                                                                    (rec__ada___names__data__name_entry__next_hash
                                                                    (us_split_fields1
                                                                    o4))) o5)
                                                                    (exists 
                                                                    ((ptr3 Int))
                                                                    (and
                                                                    (= ptr3 o5)
                                                                    (let ((temp___4581 
                                                                    (to_string
                                                                    ptr3
                                                                    hash_table
                                                                    char_table
                                                                    entry_table)))
                                                                    (and
                                                                    (and
                                                                    (to_string__function_guard
                                                                    temp___4581
                                                                    ptr3
                                                                    hash_table
                                                                    char_table
                                                                    entry_table)
                                                                    (dynamic_invariant
                                                                    temp___4581
                                                                    true
                                                                    false
                                                                    true
                                                                    true))
                                                                    (exists 
                                                                    ((spark__branch3 Bool))
                                                                    (and
                                                                    (= spark__branch3 
                                                                    (bool_eq
                                                                    (to_array
                                                                    temp___4581)
                                                                    (first
                                                                    temp___4581)
                                                                    (last
                                                                    temp___4581)
                                                                    (to_array
                                                                    s)
                                                                    (first s)
                                                                    (last s)))
                                                                    (= spark__branch3 true)))))))))))))))))))))))))))))))
                                                  (= entry_table1 entry_table))
                                                (= char_table1 char_table))
                                              (= hash_table1 hash_table))
                                            (exists ((spark__branch1 Bool) (n2 Int) (ptr1 Int))
                                              (and
                                                (exists ((spark__branch2 Bool))
                                                  (and
                                                    (= spark__branch2 
                                                    (ite (in_range6 n1)
                                                      true
                                                      false))
                                                    (ite (= spark__branch2 true)
                                                      (exists ((ptr2 Int))
                                                        (and
                                                          (= ptr2 n1)
                                                          (let ((temp___458 
                                                            (to_string
                                                              ptr2
                                                              hash_table
                                                              char_table
                                                              entry_table)))
                                                            (and
                                                              (and
                                                                (to_string__function_guard
                                                                  temp___458
                                                                  ptr2
                                                                  hash_table
                                                                  char_table
                                                                  entry_table)
                                                                (dynamic_invariant
                                                                  temp___458
                                                                  true
                                                                  false
                                                                  true
                                                                  true))
                                                              (exists 
                                                                ((spark__branch3 Bool))
                                                                (and
                                                                  (= spark__branch3 
                                                                  (bool_eq
                                                                    (to_array
                                                                    temp___458)
                                                                    (first
                                                                    temp___458)
                                                                    (last
                                                                    temp___458)
                                                                    (to_array
                                                                    s)
                                                                    (first s)
                                                                    (last s)))
                                                                  (and
                                                                    (not
                                                                    (= spark__branch3 true))
                                                                    (and
                                                                    (=
                                                                    (= 
                                                                    (invariant__
                                                                    hash_table
                                                                    char_table
                                                                    entry_table) true)
                                                                    (and
                                                                    (and
                                                                    (= 
                                                                    (valid_tables
                                                                    char_table
                                                                    entry_table) true)
                                                                    (= 
                                                                    (valid_name_table
                                                                    char_table
                                                                    entry_table) true))
                                                                    (= 
                                                                    (valid_hashes
                                                                    hash_table
                                                                    entry_table) true)))
                                                                    (and
                                                                    (in_range3
                                                                    (last_index
                                                                    entry_table))
                                                                    (exists 
                                                                    ((ptr3 Int))
                                                                    (and
                                                                    (and
                                                                    (and
                                                                    (in_range6
                                                                    ptr3)
                                                                    (<= ptr3 
                                                                    (last_index
                                                                    entry_table)))
                                                                    (= 
                                                                    (invariant__
                                                                    hash_table
                                                                    char_table
                                                                    entry_table) true))
                                                                    (and
                                                                    (and
                                                                    (in_range4
                                                                    ptr3)
                                                                    (= n2 n1))
                                                                    (let ((o2 
                                                                    (element
                                                                    entry_table
                                                                    ptr3)))
                                                                    (and
                                                                    (= 
                                                                    (bool_eq1
                                                                    o2
                                                                    (get
                                                                    (model1
                                                                    entry_table)
                                                                    ptr3)) true)
                                                                    (exists 
                                                                    ((o3 Int))
                                                                    (and
                                                                    (= 
                                                                    (to_rep3
                                                                    (rec__ada___names__data__name_entry__next_hash
                                                                    (us_split_fields1
                                                                    o2))) o3)
                                                                    (and
                                                                    (= o3 0)
                                                                    (= ptr1 ptr3))))))))))))))))))
                                                      (and
                                                        (and
                                                          (= spark__branch1 spark__branch2)
                                                          (= n2 n1))
                                                        (= ptr1 ptr)))))
                                                (exists ((entry_table2 us_rep) (n3 Int))
                                                  (and
                                                    (and
                                                      (and
                                                        (and
                                                          (and
                                                            (= (invariant__
                                                                 hash_table
                                                                 char_table1
                                                                 entry_table2) true)
                                                            (= (length4
                                                                 entry_table2) (+ 
                                                            (length4
                                                              entry_table) 1)))
                                                          (<= (length2
                                                                char_table) 
                                                          (length2
                                                            char_table1)))
                                                        (= n3 (last_index
                                                                entry_table2)))
                                                      (in_range4 n3))
                                                    (exists ((spark__branch2 Bool))
                                                      (and
                                                        (= spark__branch2 
                                                        (ite (in_range6 ptr1)
                                                          true
                                                          false))
                                                        (ite (= spark__branch2 true)
                                                          (and
                                                            (let ((temp___465 
                                                              (element
                                                                entry_table2
                                                                ptr1)))
                                                              (and
                                                                (= (bool_eq1
                                                                    temp___465
                                                                    (get
                                                                    (model1
                                                                    entry_table2)
                                                                    ptr1)) true)
                                                                (let ((usq_ 
                                                                  (us_split_fields1
                                                                    temp___465)))
                                                                  (exists 
                                                                    ((o2 name_id))
                                                                    (and
                                                                    (= 
                                                                    (to_rep3
                                                                    o2) n3)
                                                                    (and
                                                                    (in_range6
                                                                    ptr1)
                                                                    (and
                                                                    (and
                                                                    (= 
                                                                    (length4
                                                                    entry_table1) 
                                                                    (length4
                                                                    entry_table2))
                                                                    (= 
                                                                    (get
                                                                    (model1
                                                                    entry_table1)
                                                                    ptr1) 
                                                                    (us_repqtmk
                                                                    (us_split_fieldsqtmk
                                                                    (rec__ada___names__data__name_entry__table_index
                                                                    usq_)
                                                                    (rec__ada___names__data__name_entry__length
                                                                    usq_)
                                                                    o2))))
                                                                    (= 
                                                                    (equal_except
                                                                    (model1
                                                                    entry_table2)
                                                                    (model1
                                                                    entry_table1)
                                                                    ptr1) true))))))))
                                                            (= hash_table1 hash_table))
                                                          (and
                                                            (exists ((o2 name_id))
                                                              (and
                                                                (= (to_rep3
                                                                    o2) n3)
                                                                (= hash_table1 (store hash_table 
                                                                h o2))))
                                                            (= entry_table1 entry_table2))))))))))))))))))))))))
              (= (valid_name_table char_table1 entry_table1) true)))))))))

(check-sat)
(get-info :reason-unknown)
