;; produced by z3_gnatprove.drv ;;
(set-info :smt-lib-version 2.5)
(set-info :source |VC generated by SPARK 2014|)
(set-info :category industrial)
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(define-fun __cdiv ((x Int) (y Int)) Int (ite (>= x 0) (div x y) (- (div (- x) y))))
(define-fun __cmod ((x Int) (y Int)) Int (ite (>= x 0) (mod x y) (- (mod (- x) y))))
(declare-sort us_private 0)

(declare-const us_null_ext__ us_private)

(declare-datatypes ()
  ((int__ref (int__refqtmk (int__content Int)))))

;; "in_range"
(define-fun in_range ((x Int)) Bool
  (and (<= 0 x) (<= x 2147483647)))

;; "mod"
(define-fun mod1 ((x Int) (y Int)) Int
  (ite (<= 0 y) (mod x y) (- (mod (- x) y))))

;; "min"
(define-fun min ((x Int) (y Int)) Int
  (ite (<= x y) x y))

;; "are_coprime"
(define-fun are_coprime ((param__v1 Int) (param__v2 Int)) Bool
  (and (and (> param__v1 0) (> param__v2 0)) (ite (forall ((v Int))
                                                    (=>
                                                      (and
                                                        (<= 2 v)
                                                        (<= v (min
                                                                param__v1
                                                                param__v2)))
                                                      (not
                                                        (and
                                                          (= (mod1
                                                               param__v1
                                                               v) 0)
                                                          (= (mod1
                                                               param__v2
                                                               v) 0)))))
                                               true
                                               false)))

(declare-const value Int)

(declare-datatypes ()
  ((map__ref (map__refqtmk (map__content (Array Int Bool))))))

;; "euclid"
(declare-fun euclid (Int
  Int) Int)

;; "euclid__function_guard"
(declare-fun euclid__function_guard (Int
  Int
  Int) Bool)

(declare-const value__size Int)

(declare-const object__size Int)

(declare-const component__size Int)

(declare-const alignment Int)

;; "value__size_axiom"
(assert (<= 0 value__size))

;; "object__size_axiom"
(assert (<= 0 object__size))

;; "component__size_axiom"
(assert (<= 0 component__size))

;; "alignment_axiom"
(assert (<= 0 alignment))

(declare-const result__ (Array Int Bool))

;; "result__'unused"
(define-fun result__qtunused () map__ref
  (map__refqtmk result__))

;; "Assume"
(assert (in_range value))

;; "Assume"
(assert (<= 2 value))

;; "Assume"
(assert true)

;; "Assume"
(assert true)

(declare-const index Int)

;; "index'unused"
(define-fun indexqtunused () int__ref
  (int__refqtmk index))

;; "H"
(assert (= index 0))

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused () Int
  index)

;; "o"
(define-fun o () Bool
  (ite (<= index 100000) true false))

;; "infix <='result'unused"
(define-fun infix_lseqqtresultqtunused () Bool
  o)

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused1 () Int
  index)

;; "o"
(define-fun o1 () Bool
  (ite (<= 0 index) true false))

;; "infix <='result'unused"
(define-fun infix_lseqqtresultqtunused1 () Bool
  o1)

;; "o"
(define-fun o2 () Bool
  (and o1 o))

;; "andb'result'unused"
(define-fun andbqtresultqtunused () Bool
  o2)

;; "H"
(assert (= o2 true))

;; "temp___loop_entry_250'unused"
(define-fun temp___loop_entry_250qtunused () (Array Int Bool)
  result__)

;; "map__content'result'unused"
(define-fun map__contentqtresultqtunused () (Array Int Bool)
  result__)

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused2 () Int
  index)

;; "o"
(define-fun o3 () Int
  value)

;; "o"
(define-fun o4 () Int
  (euclid o3 index))

;; "H"
(assert (euclid__function_guard o4 o3 index))

;; "H"
(assert (in_range o4))

;; "H"
(assert (ite (= (are_coprime o3 index) true) (= o4 1) (< 1 o4)))

;; "euclid'result'unused"
(define-fun euclidqtresultqtunused () Int
  o4)

;; "o"
(define-fun o5 () Bool
  (ite (= o4 1) true false))

;; "infix ='result'unused"
(define-fun infix_eqqtresultqtunused () Bool
  o5)

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused3 () Int
  index)

;; "map__content'result'unused"
(define-fun map__contentqtresultqtunused1 () (Array Int Bool)
  result__)

;; "o"
(define-fun o6 () (Array Int Bool)
  (store result__ index o5))

;; "set'result'unused"
(define-fun setqtresultqtunused () (Array Int Bool)
  o6)

(declare-const result__1 (Array Int Bool))

;; "result__'unused"
(define-fun result__qtunused1 () map__ref
  (map__refqtmk result__1))

;; "H"
(assert (= result__1 o6))

(declare-const usf Int)

(declare-const anyqtresultqtunused Int)

;; "H"
(assert (= anyqtresultqtunused usf))

(declare-const vqtunused Int)

;; "H"
(assert (= vqtunused usf))

(declare-const int__contentqtresultqtunused4 Int)

;; "H"
(assert (= int__contentqtresultqtunused4 index))

(declare-const o7 Bool)

;; "H"
(assert (= o7 (ite (<= usf index) true false)))

(declare-const infix_lseqqtresultqtunused2 Bool)

;; "H"
(assert (= infix_lseqqtresultqtunused2 o7))

(declare-const o8 Bool)

;; "H"
(assert (= o8 (ite (<= 0 usf) true false)))

(declare-const infix_lseqqtresultqtunused3 Bool)

;; "H"
(assert (= infix_lseqqtresultqtunused3 o8))

(declare-const andbqtresultqtunused1 Bool)

;; "H"
(assert (= andbqtresultqtunused1 (and o8 o7)))

;; "_f'unused"
(define-fun usfqtunused () Bool
  (ite (forall ((v Int))
         (=>
           (and (<= 0 v) (<= v index))
           (= (= (select result__1 v) true) (= (are_coprime value v) true))))
    true
    false))

;; "any'result'unused"
(define-fun anyqtresultqtunused1 () Bool
  (ite (forall ((v Int))
         (=>
           (and (<= 0 v) (<= v index))
           (= (= (select result__1 v) true) (= (are_coprime value v) true))))
    true
    false))

(declare-const result__2 (Array Int Bool))

(declare-const index1 Int)

;; "index'unused"
(define-fun indexqtunused1 () int__ref
  (int__refqtmk index1))

;; "result__'unused"
(define-fun result__qtunused2 () map__ref
  (map__refqtmk result__2))

;; "LoopInvariant"
(assert
  (forall ((v Int))
    (=>
      (and (<= 0 v) (<= v index1))
      (= (= (select result__2 v) true) (= (are_coprime value v) true)))))

;; "Assume"
(assert
  (= (and (ite (forall ((temp___251 Int))
                 (=>
                   (and (<= 0 temp___251) (<= temp___251 100000))
                   (=>
                     (or
                       (< 100000 temp___251)
                       (or (< temp___251 0) (< index1 temp___251)))
                     (= (select result__2 temp___251) (select result__ temp___251)))))
            true
            false) (ite (and (<= 0 index1) (<= index1 100000)) true false)) true))

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused5 () Int
  index1)

;; "infix ='result'unused"
(define-fun infix_eqqtresultqtunused1 () Bool
  (ite (= index1 100000) true false))

;; "H"
(assert (not (= index1 100000)))

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused6 () Int
  index1)

;; "o"
(define-fun o9 () Int
  (+ index1 1))

;; "infix +'result'unused"
(define-fun infix_plqtresultqtunused () Int
  o9)

(declare-const index2 Int)

;; "index'unused"
(define-fun indexqtunused2 () int__ref
  (int__refqtmk index2))

;; "H"
(assert (= index2 o9))

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused7 () Int
  index2)

;; "o"
(define-fun o10 () Int
  value)

;; "o"
(define-fun o11 () Int
  (euclid o10 index2))

;; "H"
(assert (euclid__function_guard o11 o10 index2))

;; "H"
(assert (in_range o11))

;; "H"
(assert (ite (= (are_coprime o10 index2) true) (= o11 1) (< 1 o11)))

;; "euclid'result'unused"
(define-fun euclidqtresultqtunused1 () Int
  o11)

;; "o"
(define-fun o12 () Bool
  (ite (= o11 1) true false))

;; "infix ='result'unused"
(define-fun infix_eqqtresultqtunused2 () Bool
  o12)

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused8 () Int
  index2)

;; "map__content'result'unused"
(define-fun map__contentqtresultqtunused2 () (Array Int Bool)
  result__2)

;; "o"
(define-fun o13 () (Array Int Bool)
  (store result__2 index2 o12))

;; "set'result'unused"
(define-fun setqtresultqtunused1 () (Array Int Bool)
  o13)

(declare-const result__3 (Array Int Bool))

;; "result__'unused"
(define-fun result__qtunused3 () map__ref
  (map__refqtmk result__3))

;; "H"
(assert (= result__3 o13))

(declare-const usf1 Int)

(declare-const anyqtresultqtunused2 Int)

;; "H"
(assert (= anyqtresultqtunused2 usf1))

(declare-const vqtunused1 Int)

;; "H"
(assert (= vqtunused1 usf1))

(declare-const int__contentqtresultqtunused9 Int)

;; "H"
(assert (= int__contentqtresultqtunused9 index2))

(declare-const o14 Bool)

;; "H"
(assert (= o14 (ite (<= usf1 index2) true false)))

(declare-const infix_lseqqtresultqtunused4 Bool)

;; "H"
(assert (= infix_lseqqtresultqtunused4 o14))

(declare-const o15 Bool)

;; "H"
(assert (= o15 (ite (<= 0 usf1) true false)))

(declare-const infix_lseqqtresultqtunused5 Bool)

;; "H"
(assert (= infix_lseqqtresultqtunused5 o15))

(declare-const andbqtresultqtunused2 Bool)

;; "H"
(assert (= andbqtresultqtunused2 (and o15 o14)))

;; "_f'unused"
(define-fun usfqtunused1 () Bool
  (ite (forall ((v Int))
         (=>
           (and (<= 0 v) (<= v index2))
           (= (= (select result__3 v) true) (= (are_coprime value v) true))))
    true
    false))

;; "any'result'unused"
(define-fun anyqtresultqtunused3 () Bool
  (ite (forall ((v Int))
         (=>
           (and (<= 0 v) (<= v index2))
           (= (= (select result__3 v) true) (= (are_coprime value v) true))))
    true
    false))

(declare-const v Int)

;; "H"
(assert (<= 0 v))

;; "H"
(assert (<= v index2))

;; "H"
(assert (= (select result__3 v) true))

;; Goal "def'vc"
;; File "prime_and_coprime_numbers.ads", line 51, characters 0-0
(assert
  (not (= (are_coprime value v) true)))

(check-sat)
