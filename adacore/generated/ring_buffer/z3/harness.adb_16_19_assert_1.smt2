;; produced by z3_gnatprove.drv ;;
(set-info :smt-lib-version 2.5)
(set-info :source |VC generated by SPARK 2014|)
(set-info :category industrial)
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort us_private 0)

(declare-const us_null_ext__ us_private)

(declare-datatypes ()
  ((int__ref (int__refqtmk (int__content Int)))))

(declare-sort integer 0)

;; "integer'int"
(declare-fun integerqtint (integer) Int)

;; "integer'axiom"
(assert
  (forall ((i integer))
    (and
      (<= (- 2147483648) (integerqtint i))
      (<= (integerqtint i) 2147483647))))

;; "in_range"
(define-fun in_range ((x Int)) Bool
  (and (<= (- 2147483648) x) (<= x 2147483647)))

(declare-const x Int)

(declare-const y Int)

(declare-const z Int)

(declare-sort ar_index 0)

;; "ar_index'int"
(declare-fun ar_indexqtint (ar_index) Int)

;; "ar_index'axiom"
(assert
  (forall ((i ar_index))
    (and (<= 0 (ar_indexqtint i)) (<= (ar_indexqtint i) 9999))))

;; "in_range"
(define-fun in_range1 ((x1 Int)) Bool
  (and (<= 0 x1) (<= x1 9999)))

;; "to_rep"
(define-fun to_rep ((x1 ar_index)) Int
  (ar_indexqtint x1))

;; "of_rep"
(declare-fun of_rep (Int) ar_index)

;; "inversion_axiom"
(assert
  (forall ((x1 ar_index))
    (! (= (of_rep (to_rep x1)) x1) :pattern ((to_rep x1)) )))

;; "range_axiom"
(assert
  (forall ((x1 ar_index))
    (! (in_range1 (to_rep x1)) :pattern ((to_rep x1)) )))

;; "coerce_axiom"
(assert
  (forall ((x1 Int))
    (! (=> (in_range1 x1) (= (to_rep (of_rep x1)) x1)) :pattern ((to_rep
                                                                   (of_rep
                                                                    x1))) )))

;; "to_rep"
(define-fun to_rep1 ((x1 integer)) Int
  (integerqtint x1))

;; "of_rep"
(declare-fun of_rep1 (Int) integer)

;; "inversion_axiom"
(assert
  (forall ((x1 integer))
    (! (= (of_rep1 (to_rep1 x1)) x1) :pattern ((to_rep1 x1)) )))

;; "range_axiom"
(assert
  (forall ((x1 integer))
    (! (in_range (to_rep1 x1)) :pattern ((to_rep1 x1)) )))

;; "coerce_axiom"
(assert
  (forall ((x1 Int))
    (! (=> (in_range x1) (= (to_rep1 (of_rep1 x1)) x1)) :pattern ((to_rep1
                                                                    (of_rep1
                                                                    x1))) )))

(declare-const value__size Int)

(declare-const object__size Int)

(declare-const component__size Int)

(declare-const alignment Int)

;; "value__size_axiom"
(assert (<= 0 value__size))

;; "object__size_axiom"
(assert (<= 0 object__size))

;; "component__size_axiom"
(assert (<= 0 component__size))

;; "alignment_axiom"
(assert (<= 0 alignment))

(declare-sort length_type 0)

;; "length_type'int"
(declare-fun length_typeqtint (length_type) Int)

;; "length_type'axiom"
(assert
  (forall ((i length_type))
    (and (<= 0 (length_typeqtint i)) (<= (length_typeqtint i) 10000))))

;; "in_range"
(define-fun in_range2 ((x1 Int)) Bool
  (and (<= 0 x1) (<= x1 10000)))

;; "to_rep"
(define-fun to_rep2 ((x1 length_type)) Int
  (length_typeqtint x1))

;; "of_rep"
(declare-fun of_rep2 (Int) length_type)

;; "inversion_axiom"
(assert
  (forall ((x1 length_type))
    (! (= (of_rep2 (to_rep2 x1)) x1) :pattern ((to_rep2 x1)) )))

;; "range_axiom"
(assert
  (forall ((x1 length_type))
    (! (in_range2 (to_rep2 x1)) :pattern ((to_rep2 x1)) )))

;; "coerce_axiom"
(assert
  (forall ((x1 Int))
    (! (=> (in_range2 x1) (= (to_rep2 (of_rep2 x1)) x1)) :pattern ((to_rep2
                                                                    (of_rep2
                                                                    x1))) )))

(declare-datatypes ()
  ((us_split_fields
   (us_split_fieldsqtmk
   (rec__ring_buf__ring_buffer__data (Array Int integer))(rec__ring_buf__ring_buffer__first ar_index)(rec__ring_buf__ring_buffer__length length_type)))))

(declare-datatypes ()
  ((us_split_fields__ref
   (us_split_fields__refqtmk (us_split_fields__content us_split_fields)))))

(declare-datatypes ()
  ((us_rep (us_repqtmk (us_split_fields1 us_split_fields)))))

(declare-const value__size1 Int)

(declare-const object__size1 Int)

(declare-const alignment1 Int)

;; "value__size_axiom"
(assert (<= 0 value__size1))

;; "object__size_axiom"
(assert (<= 0 object__size1))

;; "alignment_axiom"
(assert (<= 0 alignment1))

(declare-const ring_buf__ring_buffer__data__first__bit Int)

(declare-const ring_buf__ring_buffer__data__last__bit Int)

(declare-const ring_buf__ring_buffer__data__position Int)

;; "ring_buf__ring_buffer__data__first__bit_axiom"
(assert (<= 0 ring_buf__ring_buffer__data__first__bit))

;; "ring_buf__ring_buffer__data__last__bit_axiom"
(assert
  (< ring_buf__ring_buffer__data__first__bit ring_buf__ring_buffer__data__last__bit))

;; "ring_buf__ring_buffer__data__position_axiom"
(assert (<= 0 ring_buf__ring_buffer__data__position))

(declare-const ring_buf__ring_buffer__first__first__bit Int)

(declare-const ring_buf__ring_buffer__first__last__bit Int)

(declare-const ring_buf__ring_buffer__first__position Int)

;; "ring_buf__ring_buffer__first__first__bit_axiom"
(assert (<= 0 ring_buf__ring_buffer__first__first__bit))

;; "ring_buf__ring_buffer__first__last__bit_axiom"
(assert
  (< ring_buf__ring_buffer__first__first__bit ring_buf__ring_buffer__first__last__bit))

;; "ring_buf__ring_buffer__first__position_axiom"
(assert (<= 0 ring_buf__ring_buffer__first__position))

(declare-const ring_buf__ring_buffer__length__first__bit Int)

(declare-const ring_buf__ring_buffer__length__last__bit Int)

(declare-const ring_buf__ring_buffer__length__position Int)

;; "ring_buf__ring_buffer__length__first__bit_axiom"
(assert (<= 0 ring_buf__ring_buffer__length__first__bit))

;; "ring_buf__ring_buffer__length__last__bit_axiom"
(assert
  (< ring_buf__ring_buffer__length__first__bit ring_buf__ring_buffer__length__last__bit))

;; "ring_buf__ring_buffer__length__position_axiom"
(assert (<= 0 ring_buf__ring_buffer__length__position))

(declare-const dummy us_rep)

;; "dynamic_invariant"
(define-fun dynamic_invariant ((temp___expr_200 us_rep) (temp___is_init_196 Bool) (temp___skip_constant_197 Bool) (temp___do_toplevel_198 Bool) (temp___do_typ_inv_199 Bool)) Bool
  true)

;; "is_empty"
(declare-fun is_empty (us_rep) Bool)

;; "head"
(declare-fun head (us_rep) Int)

;; "head__function_guard"
(declare-fun head__function_guard (Int
  us_rep) Bool)

;; "is_empty__post_axiom"
(assert true)

;; "is_empty__def_axiom"
(assert
  (forall ((param__r us_rep))
    (! (=
         (= (is_empty param__r) true)
         (= (to_rep2
              (rec__ring_buf__ring_buffer__length
                (us_split_fields1 param__r))) 0)) :pattern ((is_empty
                                                              param__r)) )))

;; "head__post_axiom"
(assert
  (forall ((param__r us_rep))
    (! (=>
         (and
           (dynamic_invariant param__r true false true true)
           (not (= (is_empty param__r) true)))
         (let ((result (head param__r)))
           (=> (head__function_guard result param__r) (in_range result)))) :pattern (
    (head
      param__r)) )))

;; "head__def_axiom"
(assert
  (forall ((param__r us_rep))
    (! (= (head param__r) (to_rep1
                            (let ((temp___215 (rec__ring_buf__ring_buffer__data
                                                (us_split_fields1 param__r))))
                              (select temp___215 (to_rep
                                                   (rec__ring_buf__ring_buffer__first
                                                     (us_split_fields1
                                                       param__r))))))) :pattern (
    (head
      param__r)) )))

(declare-const r__split_fields us_split_fields)

(declare-const h Int)

;; "h'unused"
(define-fun hqtunused () int__ref
  (int__refqtmk h))

;; "r__split_fields'unused"
(define-fun r__split_fieldsqtunused () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields))

;; "Assume"
(assert (in_range x))

;; "Assume"
(assert (in_range y))

;; "Assume"
(assert (in_range z))

;; "Assume"
(assert true)

;; "Assume"
(assert
  (dynamic_invariant (us_repqtmk r__split_fields) false false true true))

;; "Assume"
(assert true)

;; "Assume"
(assert (in_range h))

;; "__split_fields__content'result'unused"
(define-fun us_split_fields__contentqtresultqtunused () us_split_fields
  r__split_fields)

;; "__rep'mk'result'unused"
(define-fun us_repqtmkqtresultqtunused () us_rep
  (us_repqtmk r__split_fields))

(declare-const r__split_fields1 us_split_fields)

;; "r__split_fields'unused"
(define-fun r__split_fieldsqtunused1 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields1))

;; "H"
(assert (= (is_empty (us_repqtmk r__split_fields1)) true))

;; "H"
(assert
  (dynamic_invariant (us_repqtmk r__split_fields1) true true true true))

;; "H"
(assert true)

;; "H"
(assert true)

;; "__split_fields__content'result'unused"
(define-fun us_split_fields__contentqtresultqtunused1 () us_split_fields
  r__split_fields1)

;; "__rep'mk'result'unused"
(define-fun us_repqtmkqtresultqtunused1 () us_rep
  (us_repqtmk r__split_fields1))

;; "param__r__split_fields'unused"
(define-fun param__r__split_fieldsqtunused () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields1))

(declare-const r__split_fields2 us_split_fields)

;; "r__split_fields'unused"
(define-fun r__split_fieldsqtunused2 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields2))

;; "H"
(assert
  (= (to_rep2 (rec__ring_buf__ring_buffer__length r__split_fields2)) (+ 
  (to_rep2
    (rec__ring_buf__ring_buffer__length r__split_fields1)) 1)))

;; "H"
(assert
  (dynamic_invariant (us_repqtmk r__split_fields2) true true true true))

;; "H"
(assert true)

;; "H"
(assert true)

;; "__split_fields__content'result'unused"
(define-fun us_split_fields__contentqtresultqtunused2 () us_split_fields
  r__split_fields2)

;; "__rep'mk'result'unused"
(define-fun us_repqtmkqtresultqtunused2 () us_rep
  (us_repqtmk r__split_fields2))

;; "param__r__split_fields'unused"
(define-fun param__r__split_fieldsqtunused1 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields2))

(declare-const r__split_fields3 us_split_fields)

;; "r__split_fields'unused"
(define-fun r__split_fieldsqtunused3 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields3))

;; "H"
(assert
  (= (to_rep2 (rec__ring_buf__ring_buffer__length r__split_fields3)) (+ 
  (to_rep2
    (rec__ring_buf__ring_buffer__length r__split_fields2)) 1)))

;; "H"
(assert
  (dynamic_invariant (us_repqtmk r__split_fields3) true true true true))

;; "H"
(assert true)

;; "H"
(assert true)

;; "__split_fields__content'result'unused"
(define-fun us_split_fields__contentqtresultqtunused3 () us_split_fields
  r__split_fields3)

;; "__rep'mk'result'unused"
(define-fun us_repqtmkqtresultqtunused3 () us_rep
  (us_repqtmk r__split_fields3))

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused () Int
  h)

;; "param__r__split_fields'unused"
(define-fun param__r__split_fieldsqtunused2 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields3))

(declare-const r__split_fields4 us_split_fields)

(declare-const h1 Int)

;; "h'unused"
(define-fun hqtunused1 () int__ref
  (int__refqtmk h1))

;; "r__split_fields'unused"
(define-fun r__split_fieldsqtunused4 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields4))

;; "H"
(assert
  (forall ((temp___217 us_rep))
    (head__function_guard (head temp___217) temp___217)))

;; "H"
(assert
  (= (to_rep2 (rec__ring_buf__ring_buffer__length r__split_fields4)) (- 
  (to_rep2
    (rec__ring_buf__ring_buffer__length r__split_fields3)) 1)))

;; "H"
(assert
  (= (let ((temp___217 (us_repqtmk r__split_fields3))) (head temp___217)) 
  h1))

;; "H"
(assert
  (dynamic_invariant (us_repqtmk r__split_fields4) true true true true))

;; "H"
(assert (in_range h1))

;; "H"
(assert true)

;; "H"
(assert true)

;; "Assert"
(assert (= h1 x))

;; "__split_fields__content'result'unused"
(define-fun us_split_fields__contentqtresultqtunused4 () us_split_fields
  r__split_fields4)

;; "__rep'mk'result'unused"
(define-fun us_repqtmkqtresultqtunused4 () us_rep
  (us_repqtmk r__split_fields4))

;; "param__r__split_fields'unused"
(define-fun param__r__split_fieldsqtunused3 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields4))

(declare-const r__split_fields5 us_split_fields)

;; "r__split_fields'unused"
(define-fun r__split_fieldsqtunused5 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields5))

;; "H"
(assert
  (= (to_rep2 (rec__ring_buf__ring_buffer__length r__split_fields5)) (+ 
  (to_rep2
    (rec__ring_buf__ring_buffer__length r__split_fields4)) 1)))

;; "H"
(assert
  (dynamic_invariant (us_repqtmk r__split_fields5) true true true true))

;; "H"
(assert true)

;; "H"
(assert true)

;; "__split_fields__content'result'unused"
(define-fun us_split_fields__contentqtresultqtunused5 () us_split_fields
  r__split_fields5)

;; "__rep'mk'result'unused"
(define-fun us_repqtmkqtresultqtunused5 () us_rep
  (us_repqtmk r__split_fields5))

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused1 () Int
  h1)

;; "param__r__split_fields'unused"
(define-fun param__r__split_fieldsqtunused4 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields5))

(declare-const r__split_fields6 us_split_fields)

(declare-const h2 Int)

;; "h'unused"
(define-fun hqtunused2 () int__ref
  (int__refqtmk h2))

;; "r__split_fields'unused"
(define-fun r__split_fieldsqtunused6 () us_split_fields__ref
  (us_split_fields__refqtmk r__split_fields6))

;; "H"
(assert
  (forall ((temp___217 us_rep))
    (head__function_guard (head temp___217) temp___217)))

;; "H"
(assert
  (= (to_rep2 (rec__ring_buf__ring_buffer__length r__split_fields6)) (- 
  (to_rep2
    (rec__ring_buf__ring_buffer__length r__split_fields5)) 1)))

;; "H"
(assert
  (= (let ((temp___217 (us_repqtmk r__split_fields5))) (head temp___217)) 
  h2))

;; "H"
(assert
  (dynamic_invariant (us_repqtmk r__split_fields6) true true true true))

;; "H"
(assert (in_range h2))

;; "H"
(assert true)

;; "H"
(assert true)

;; Goal "def'vc"
;; File "harness.adb", line 3, characters 0-0
(assert
  (not (= h2 y)))

(check-sat)
