;; produced by z3_gnatprove.drv ;;
(set-info :smt-lib-version 2.5)
(set-info :source |VC generated by SPARK 2014|)
(set-info :category industrial)
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort us_private 0)

(declare-const us_null_ext__ us_private)

(declare-datatypes ()
  ((int__ref (int__refqtmk (int__content Int)))))

(declare-const two_power_size_minus_one Int)

(declare-const two_power_size_minus_one1 Int)

(declare-datatypes ()
  ((t__ref (t__refqtmk (t__content (_ BitVec 32))))))

(declare-sort integer 0)

;; "integer'int"
(declare-fun integerqtint (integer) Int)

;; "integer'axiom"
(assert
  (forall ((i integer))
    (and
      (<= (- 2147483648) (integerqtint i))
      (<= (integerqtint i) 2147483647))))

;; "in_range"
(define-fun in_range ((x Int)) Bool
  (and (<= (- 2147483648) x) (<= x 2147483647)))

;; "in_range"
(define-fun in_range1 ((x Int)) Bool
  (and (<= 0 x) (<= x 2147483647)))

(declare-sort positive 0)

;; "positive'int"
(declare-fun positiveqtint (positive) Int)

;; "positive'axiom"
(assert
  (forall ((i positive))
    (and (<= 1 (positiveqtint i)) (<= (positiveqtint i) 2147483647))))

;; "in_range"
(define-fun in_range2 ((x Int)) Bool
  (and (<= 1 x) (<= x 2147483647)))

(declare-datatypes ()
  ((positive__init_wrapper
   (positive__init_wrapperqtmk (rec__value positive)(us_attr__init Bool)))))

(declare-const dummy positive__init_wrapper)

;; "dummy__def"
(assert (= (us_attr__init dummy) false))

;; "to_rep"
(define-fun to_rep ((x positive)) Int
  (positiveqtint x))

;; "of_rep"
(declare-fun of_rep (Int) positive)

;; "inversion_axiom"
(assert
  (forall ((x positive))
    (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; "range_axiom"
(assert
  (forall ((x positive)) (! (in_range2 (to_rep x)) :pattern ((to_rep x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range2 x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                                (of_rep x))) )))

(declare-sort character 0)

;; "in_range"
(define-fun in_range3 ((x Int)) Bool
  (and (<= 0 x) (<= x 255)))

(declare-datatypes ()
  ((character__init_wrapper
   (character__init_wrapperqtmk (rec__value1 character)(us_attr__init1 Bool)))))

(declare-const dummy1 character__init_wrapper)

;; "dummy__def"
(assert (= (us_attr__init1 dummy1) false))

;; "to_rep"
(declare-fun to_rep1 (character) Int)

;; "of_rep"
(declare-fun of_rep1 (Int) character)

;; "inversion_axiom"
(assert
  (forall ((x character))
    (! (= (of_rep1 (to_rep1 x)) x) :pattern ((to_rep1 x)) )))

;; "range_axiom"
(assert
  (forall ((x character))
    (! (in_range3 (to_rep1 x)) :pattern ((to_rep1 x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range3 x) (= (to_rep1 (of_rep1 x)) x)) :pattern ((to_rep1
                                                                  (of_rep1 x))) )))

(declare-datatypes ()
  ((map__ref
   (map__refqtmk (map__content (Array Int character__init_wrapper))))))

;; "to_rep"
(define-fun to_rep2 ((x integer)) Int
  (integerqtint x))

;; "of_rep"
(declare-fun of_rep2 (Int) integer)

;; "inversion_axiom"
(assert
  (forall ((x integer))
    (! (= (of_rep2 (to_rep2 x)) x) :pattern ((to_rep2 x)) )))

;; "range_axiom"
(assert
  (forall ((x integer)) (! (in_range (to_rep2 x)) :pattern ((to_rep2 x)) )))

;; "coerce_axiom"
(assert
  (forall ((x Int))
    (! (=> (in_range x) (= (to_rep2 (of_rep2 x)) x)) :pattern ((to_rep2
                                                                 (of_rep2 x))) )))

(declare-const value__size Int)

(declare-const object__size Int)

(declare-const component__size Int)

(declare-const alignment Int)

;; "value__size_axiom"
(assert (<= 0 value__size))

;; "object__size_axiom"
(assert (<= 0 object__size))

;; "component__size_axiom"
(assert (<= 0 component__size))

;; "alignment_axiom"
(assert (<= 0 alignment))

(declare-datatypes ()
  ((t (tqtmk (rec__first integer)(rec__last integer)))))

;; "mk"
(declare-fun mk (Int
  Int) t)

;; "mk_def"
(assert
  (forall ((f Int) (l Int))
    (! (=>
         (in_range f)
         (=>
           (in_range l)
           (and
             (= (to_rep2 (rec__first (mk f l))) f)
             (= (to_rep2 (rec__last (mk f l))) l)))) :pattern ((mk f l)) )))

(declare-datatypes ()
  ((us_t (us_tqtmk (elts (Array Int character__init_wrapper))(rt t)))))

;; "of_array"
(define-fun of_array ((a (Array Int character__init_wrapper)) (f Int) (l Int)) us_t
  (us_tqtmk a (mk f l)))

(declare-const value__size1 Int)

(declare-const object__size1 Int)

(declare-const component__size1 Int)

(declare-const alignment1 Int)

;; "value__size_axiom"
(assert (<= 0 value__size1))

;; "object__size_axiom"
(assert (<= 0 object__size1))

;; "component__size_axiom"
(assert (<= 0 component__size1))

;; "alignment_axiom"
(assert (<= 0 alignment1))

(declare-const v (_ BitVec 32))

(declare-datatypes ()
  ((map__ref1
   (map__refqtmk1 (map__content1 (Array Int positive__init_wrapper))))))

(declare-const lst Int)

(declare-const res__first integer)

(declare-const res__last integer)

(declare-const attr__ATTRIBUTE_MODULUS (_ BitVec 8))

(declare-const attr__ATTRIBUTE_MODULUS1 (_ BitVec 32))

(declare-const value__size2 Int)

(declare-const object__size2 Int)

(declare-const component__size2 Int)

(declare-const alignment2 Int)

;; "value__size_axiom"
(assert (<= 0 value__size2))

;; "object__size_axiom"
(assert (<= 0 object__size2))

;; "component__size_axiom"
(assert (<= 0 component__size2))

;; "alignment_axiom"
(assert (<= 0 alignment2))

(declare-const value__size3 Int)

(declare-const object__size3 Int)

(declare-const component__size3 Int)

(declare-const alignment3 Int)

;; "value__size_axiom"
(assert (<= 0 value__size3))

;; "object__size_axiom"
(assert (<= 0 object__size3))

;; "component__size_axiom"
(assert (<= 0 component__size3))

;; "alignment_axiom"
(assert (<= 0 alignment3))

(declare-const s (Array Int character__init_wrapper))

(declare-const ds (Array Int positive__init_wrapper))

;; "ds'unused"
(define-fun dsqtunused () map__ref1
  (map__refqtmk1 ds))

;; "s'unused"
(define-fun sqtunused () map__ref
  (map__refqtmk s))

;; "Assume"
(assert true)

;; "Assume"
(assert true)

(declare-const last Int)

;; "last"
(define-fun last1 () int__ref
  (int__refqtmk last))

;; "H"
(assert (= last 15))

;; "Assume"
(assert (in_range1 last))

(declare-const w (_ BitVec 32))

;; "w'unused"
(define-fun wqtunused () t__ref
  (t__refqtmk w))

;; "H"
(assert (= w v))

;; "Assume"
(assert true)

;; "Assume"
(assert true)

;; "temp___loop_entry_566'unused"
(define-fun temp___loop_entry_566qtunused () (Array Int positive__init_wrapper)
  ds)

;; "map__content'result'unused"
(define-fun map__contentqtresultqtunused () (Array Int positive__init_wrapper)
  ds)

;; "temp___loop_entry_563'unused"
(define-fun temp___loop_entry_563qtunused () (_ BitVec 32)
  w)

;; "t__content'result'unused"
(define-fun t__contentqtresultqtunused () (_ BitVec 32)
  w)

;; "temp___loop_entry_562'unused"
(define-fun temp___loop_entry_562qtunused () Int
  last)

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused () Int
  last)

;; "temp___loop_entry_561'unused"
(define-fun temp___loop_entry_561qtunused () (Array Int character__init_wrapper)
  s)

;; "map__content'result'unused"
(define-fun map__contentqtresultqtunused1 () (Array Int character__init_wrapper)
  s)

(declare-const i Int)

;; "i'unused"
(define-fun iqtunused () int__ref
  (int__refqtmk i))

;; "H"
(assert (= i 1))

;; "map__content'result'unused"
(define-fun map__contentqtresultqtunused2 () (Array Int character__init_wrapper)
  s)

;; "temp___compl_549"
(define-fun temp___compl_549 () us_t
  (of_array s 1 15))

;; "of_array'result'unused"
(define-fun of_arrayqtresultqtunused () us_t
  temp___compl_549)

;; "o"
(define-fun o () (Array Int character__init_wrapper)
  s)

;; "to_array'result'unused"
(define-fun to_arrayqtresultqtunused () (Array Int character__init_wrapper)
  o)

;; "param__s"
(define-fun param__s () map__ref
  (map__refqtmk o))

;; "map__ref'mk'result'unused"
(define-fun map__refqtmkqtresultqtunused () map__ref
  param__s)

;; "int__content'result'unused"
(define-fun int__contentqtresultqtunused1 () Int
  last)

;; "o"
(define-fun o1 () Int
  15)

;; "last'result'unused"
(define-fun lastqtresultqtunused () Int
  o1)

(declare-const o2 integer)

;; "Ensures"
(assert (= (to_rep2 o2) o1))

;; "of_rep'result'unused"
(define-fun of_repqtresultqtunused () integer
  o2)

;; "o"
(define-fun o3 () Int
  1)

;; "first'result'unused"
(define-fun firstqtresultqtunused () Int
  o3)

(declare-const o4 integer)

;; "Ensures"
(assert (= (to_rep2 o4) o3))

;; "of_rep'result'unused"
(define-fun of_repqtresultqtunused1 () integer
  o4)

;; "t__content'result'unused"
(define-fun t__contentqtresultqtunused1 () (_ BitVec 32)
  w)

;; "o"
(define-fun o5 () (_ BitVec 32)
  (bvand w #x000000FF))

;; "bw_and'result'unused"
(define-fun bw_andqtresultqtunused () (_ BitVec 32)
  o5)

;; "o"
(define-fun o6 () (_ BitVec 32)
  ((_ zero_extend 24) #xFF))

;; "toBig'result'unused"
(define-fun toBigqtresultqtunused () (_ BitVec 32)
  o6)

;; "o"
(define-fun o7 () (_ BitVec 32)
  ((_ zero_extend 24) #x00))

;; "toBig'result'unused"
(define-fun toBigqtresultqtunused1 () (_ BitVec 32)
  o7)

;; Goal "def'vc"
;; File "ipv4_parsing.ads", line 118, characters 0-0
(assert
  (not (bvule o5 o6)))

(check-sat)
